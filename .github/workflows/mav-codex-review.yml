name: maverick-codex-review

# Run Codex when someone comments /codex on a PR.

on:
  issue_comment:
    types: [created]

permissions:
  contents: read

jobs:
  codex:
    permissions:
      contents: read
      pull-requests: read
    if: >-
      github.event.issue.pull_request &&
      (
        contains(github.event.comment.body, '/codex')
      )
    runs-on: ubuntu-latest
    outputs:
      final_message_b64: ${{ steps.run_codex.outputs.final-message-b64 }}
    steps:
      - uses: actions/checkout@v5
        with:
          # Explicitly check out the PR's merge commit.
          ref: refs/pull/${{ github.event.issue.number }}/merge

      - name: Get PR info (base/head)
        id: pr_info
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const prNumber = context.payload.issue.number;
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            core.setOutput('base_ref', pr.base.ref);
            core.setOutput('head_ref', pr.head.ref);
            core.setOutput('base_sha', pr.base.sha);
            core.setOutput('head_sha', pr.head.sha);
            core.setOutput('title', pr.title || '');
            core.setOutput('body', pr.body || '');

      - name: Pre-fetch base and head refs for the PR
        run: |
          git fetch --no-tags origin \
            ${{ steps.pr_info.outputs.base_ref }} \
            +refs/pull/${{ github.event.issue.number }}/head

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy,rustfmt

      - name: Cache cargo registry and build
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Pre-fetch Rust dependencies (no network needed later)
        run: cargo fetch --locked

      - name: Recreate Codex auth.json
        env:
          CODEX_ACCOUNT_ID: ${{ secrets.CODEX_ACCOUNT_ID }}
          CODEX_ID_TOKEN: ${{ secrets.CODEX_ID_TOKEN }}
          CODEX_REFRESH_TOKEN: ${{ secrets.CODEX_REFRESH_TOKEN }}
        run: |
          mkdir -p ~/.codex
          # Write OAuth tokens to Codex auth.json (secrets will be masked in logs)
          cat > ~/.codex/auth.json <<JSON
          {
            "OPENAI_API_KEY": null,
            "tokens": {
              "id_token": "${CODEX_ID_TOKEN}",
              "access_token": "abc123",
              "refresh_token": "${CODEX_REFRESH_TOKEN}",
              "account_id": "${CODEX_ACCOUNT_ID}"
            },
            "last_refresh": "2025-10-01T19:24:20.220933559Z"
          }
          JSON
          chmod 600 ~/.codex/auth.json

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Run Codex CLI
        id: run_codex
        env:
          # Optional repo variable to speed testing: set CODEX_USE_SIMPLE_PROMPT=true in Repository Variables to use a tiny prompt
          CODEX_USE_SIMPLE_PROMPT: ${{ vars.CODEX_USE_SIMPLE_PROMPT }}
        run: |
          set -euo pipefail
          # Ensure Codex home exists and auth.json is present
          test -f "$HOME/.codex/auth.json" || { echo "Missing $HOME/.codex/auth.json"; exit 1; }
          OUTPUT_FILE="$(mktemp)"
          PROMPT_FILE="$(mktemp)"

          cat > "$PROMPT_FILE" <<'PROMPT'
          This is PR #${{ github.event.issue.number }} for ${{ github.repository }}.

          You are the sole, very senior engineer reviewing this PR. Treat this as the only review gate before merge.
          Carefully read the entire PR diff and conversation and take your time to be thorough.

          Review focus and priorities (in order):
          1) Correctness and spec alignment: Verify the changes faithfully implement the requested task and PR intent
            (title/description/linked issues) and conform to repository specifications and docs (e.g., CLI/spec files
            under docs/). Call out any mismatches, missing behaviors, or ambiguous semantics.
          2) Code quality and maintainability: Assess readability, naming, structure, modularity, error handling,
            logging, public API impact, idiomatic style for the language used (Rust here), and absence of unsafe code
            (or fully justified safety invariants if present). Check adherence to project conventions.
          3) Tests and verification: Ensure appropriate unit/integration/doctests exist, are deterministic, and cover
            happy paths and key edge cases. Identify coverage gaps and recommend specific tests. If CI results are
            referenced, note failures and likely causes; otherwise, specify how to reproduce locally and the expected
            assertions.
          4) Performance and resource use: Flag unnecessary allocations/clones, blocking I/O in async paths, N+1
            patterns, suboptimal algorithms, and scalability risks. Suggest concrete, low-risk improvements.
          5) Security, reliability, and UX: Identify input validation gaps, panics, weak/opaque error messages, secret
            or credential handling issues, injection/file/network risks, backward-compatibility and migration
            concerns.

          Output requirements (produce exactly these two sections and nothing else):
          - A prioritized, bulleted list of concrete issues that must be resolved before merge. For each item include:
            - [Severity: blocking|major|minor] and Category (Correctness, Tests, Style, Performance, Security, Docs, CI).
            - What is wrong and why it matters.
            - Where: file path and line/hunk reference when possible.
            - The minimal, specific fix or verification steps (tiny inline code snippets allowed).
            - If no issues, add a single bullet: "No issues found; approved as-is."
          - Bulleted, line-level review notes tied to specific files/lines where helpful. Keep each bullet single-issue,
            with a crisp recommendation or micro-fix. Avoid platitudes; prefer precise guidance.

          Review guidance:
          - Be exhaustive and specific; assume a junior author and prefer explicit steps over vague advice.
          - Do not rewrite large code blocks; keep examples minimal and focused.
          - Cite concrete project rules when applicable (formatting, clippy/lints, test conventions, docs expectations).
          - If information is missing to judge an item, state your assumption and what evidence to look for (e.g., a test
            or doc), and classify as blocking if it affects correctness.

          Pull request title and body:
          ----
          ${{ steps.pr_info.outputs.title }}
          ${{ steps.pr_info.outputs.body }}
          PROMPT

          # Invoke Codex CLI via npx, feeding the prompt from PROMPT_FILE and writing the last message to OUTPUT_FILE.
          npx -y @openai/codex@latest exec \
            --skip-git-repo-check \
            --cd "$GITHUB_WORKSPACE" \
            --output-last-message "$OUTPUT_FILE" < "$PROMPT_FILE"
          # Expose final message as a single-line base64 output to avoid multiline delimiter issues
          # Use an intermediate variable to avoid nested quoting pitfalls that can introduce literal quotes
          b64=$(base64 -w0 "$OUTPUT_FILE")
          echo "final-message-b64=$b64" >> "$GITHUB_OUTPUT"
          rm -f "$OUTPUT_FILE" "$PROMPT_FILE"

  post_feedback:
    runs-on: ubuntu-latest
    needs: codex
    if: needs.codex.outputs.final_message_b64 != ''
    permissions:
      issues: write
      pull-requests: write
    steps:
      - name: Report Codex feedback
        uses: actions/github-script@v7
        env:
          CODEX_FINAL_MESSAGE_B64: ${{ needs.codex.outputs.final_message_b64 }}
        with:
          github-token: ${{ github.token }}
          script: |
            const b64 = process.env.CODEX_FINAL_MESSAGE_B64 || '';
            const body = Buffer.from(b64, 'base64').toString('utf8');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body,
            });