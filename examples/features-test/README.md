# Features Test Examples

This directory contains comprehensive examples demonstrating the `deacon features test` subcommand for testing Dev Container Features.

## Overview

The `features test` command executes automated tests for features in isolated container environments. It supports:

- **Autogenerated Tests**: Per-feature `test.sh` scripts validating installation
- **Scenario Tests**: Named test configurations with custom images and options
- **Duplicate/Idempotence Tests**: Verify features can be installed twice without errors
- **Global Scenarios**: Collection-wide tests in `test/_global/`

## Quick Start

```sh
# Navigate to any example
cd basic-test-suite/

# Run all tests
deacon features test .

# Run with JSON output
deacon features test . --json

# Run specific features
deacon features test . --features hello-world

# Filter scenarios
deacon features test . --filter alpine
```

## Examples Index

### 1. Basic Test Suite (`basic-test-suite/`)
**Purpose**: Complete demonstration of all test types  
**Key Concepts**: Autogenerated tests, scenarios, duplicate tests, global scenarios  
**Best For**: Learning the full testing workflow

Features:
- Two example features with options
- Multiple scenarios per feature
- Global scenarios
- All test types demonstrated

**Commands**:
```sh
cd basic-test-suite/
deacon features test .
```

---

### 2. Feature Selection (`feature-selection/`)
**Purpose**: Test only specific features using `--features`  
**Key Concepts**: Targeted testing, CI optimization  
**Best For**: Testing subsets of a large feature collection

Demonstrates:
- Selecting single features
- Selecting multiple features
- How global scenarios are excluded with `--features`

**Commands**:
```sh
cd feature-selection/
deacon features test . --features git-tools
deacon features test . --features git-tools python-tools
```

---

### 3. Scenario Filtering (`scenario-filtering/`)
**Purpose**: Run only scenarios matching a substring with `--filter`  
**Key Concepts**: Case-sensitive substring matching on scenario names  
**Best For**: Platform-specific testing, debugging specific scenarios

Demonstrates:
- Filtering by platform (postgres, mysql)
- Filtering by type (minimal, full, benchmark)
- Case-sensitive matching

**Commands**:
```sh
cd scenario-filtering/
deacon features test . --filter minimal
deacon features test . --filter postgres
```

---

### 4. Global Scenarios Only (`global-scenarios-only/`)
**Purpose**: Test only collection-wide scenarios with `--global-scenarios-only`  
**Key Concepts**: Collection validation, infrastructure tests  
**Best For**: Pre-flight checks, environment validation

Demonstrates:
- Running only `_global` scenarios
- Skipping all per-feature tests
- Environment and connectivity checks

**Commands**:
```sh
cd global-scenarios-only/
deacon features test . --global-scenarios-only
```

---

### 5. Skip Test Types (`skip-test-types/`)
**Purpose**: Selectively skip test types with `--skip-*` flags  
**Key Concepts**: Test type control, CI optimization  
**Best For**: Running specific test subsets

Demonstrates:
- `--skip-autogenerated`
- `--skip-scenarios`
- `--skip-duplicated`
- Combining skip flags

**Commands**:
```sh
cd skip-test-types/
deacon features test . --skip-duplicated
deacon features test . --skip-scenarios
```

---

### 6. JSON Output (`json-output/`)
**Purpose**: Structured JSON output for CI/CD integration  
**Key Concepts**: Machine-readable results, CI parsing  
**Best For**: Automated pipelines, result processing

Demonstrates:
- Strict JSON array output to stdout
- Logs to stderr separation
- Parsing with `jq`
- CI integration patterns

**Commands**:
```sh
cd json-output/
deacon features test . --json
deacon features test . --json | jq '.[]'
```

---

### 7. Zero Tests (`zero-tests/`)
**Purpose**: Behavior when no tests are discovered/selected  
**Key Concepts**: Exit code 0, empty result handling  
**Best For**: Understanding conditional testing behavior

Demonstrates:
- Non-matching filters
- Non-existent features
- Empty JSON output `[]`
- Exit code 0 (not an error)

**Commands**:
```sh
cd zero-tests/
deacon features test . --filter nonexistent
deacon features test . --features missing --json
```

---

### 8. Custom Environment (`custom-environment/`)
**Purpose**: Control test execution environment  
**Key Concepts**: Base images, remote users, container preservation  
**Best For**: Multi-platform testing, debugging

Demonstrates:
- `--base-image` for custom distributions
- `--remote-user` for non-root testing
- `--preserve-test-containers` for debugging
- Container inspection

**Commands**:
```sh
cd custom-environment/
deacon features test . --base-image alpine:latest
deacon features test . --remote-user vscode
deacon features test . --preserve-test-containers
```

---

## Common Patterns

### CI/CD Integration
```yaml
# GitHub Actions example
- name: Test features
  run: |
    deacon features test . --json > results.json
    
- name: Check results
  run: |
    FAILED=$(jq '[.[] | select(.result == false)] | length' results.json)
    test "$FAILED" -eq 0
```

### Local Development
```sh
# Quick test during development
deacon features test . --features my-feature --skip-duplicated

# Full validation before commit
deacon features test . --json > results.json
```

### Debugging Failures
```sh
# Preserve containers for inspection
deacon features test . --preserve-test-containers

# Find test containers
docker ps -a --filter "label=devcontainer.is_test_run=true"

# Inspect container
docker exec -it <container-id> bash
```

## Test Collection Structure

All examples follow this standard structure:

```
example-name/
├── README.md              # Documentation
├── src/                   # Feature source files
│   └── feature-id/
│       ├── devcontainer-feature.json
│       └── install.sh
└── test/                  # Test definitions
    ├── feature-id/
    │   ├── test.sh        # Autogenerated test
    │   ├── scenarios.jsonc # Scenario definitions
    │   └── test_*.sh      # Scenario test scripts
    └── _global/           # Optional global scenarios
        ├── scenarios.jsonc
        └── test_*.sh
```

## Command Reference

### Essential Flags
- `--project-folder, -p <path>`: Collection root (default: `.`)
- `--features, -f <id...>`: Test specific features only
- `--filter <string>`: Filter scenarios by name substring
- `--json`: Output JSON array to stdout

### Test Control
- `--global-scenarios-only`: Run only `_global` scenarios
- `--skip-scenarios`: Skip all scenario tests
- `--skip-autogenerated`: Skip autogenerated tests
- `--skip-duplicated`: Skip duplicate/idempotence tests

### Environment
- `--base-image <ref>`: Base container image (default: `ubuntu:focal`)
- `--remote-user <name>`: User for running scripts
- `--preserve-test-containers`: Keep containers after tests

### Output
- `--quiet`: Suppress non-error output
- `--log-level <level>`: Set log verbosity (info, debug, trace)

## DevContainer Specification References

- **[Features](https://containers.dev/implementors/spec/#features)**: Feature distribution and installation
- **[Feature Metadata](https://containers.dev/implementors/spec/#devcontainer-feature-json-properties)**: Feature manifest properties
- **[Feature Testing](https://containers.dev/implementors/spec/#testing-features)**: Testing approaches and patterns

## Related Documentation

- `docs/subcommand-specs/features-test/SPEC.md`: Complete command specification
- `specs/005-features-test-gap/spec.md`: Feature specification
- `EXAMPLES.md`: Top-level examples index

## Contributing Examples

When adding new examples:

1. Create a self-contained directory with `src/` and `test/`
2. Include a comprehensive `README.md`
3. Demonstrate one primary concept clearly
4. Provide example commands and expected output
5. Add entry to this index with purpose and key concepts
