//! Integration tests for vulnerability scan functionality

use assert_cmd::Command;
use predicates::prelude::*;
use serial_test::serial;
use std::env;
use tempfile::TempDir;

#[test]
#[serial]
fn test_cli_scan_flags_parsing() {
    // Test that CLI flags are parsed correctly
    let mut cmd = Command::cargo_bin("deacon").unwrap();
    let output = cmd.arg("build").arg("--help").assert().success();

    let output_str = String::from_utf8_lossy(&output.get_output().stdout);
    assert!(output_str.contains("--scan-image"));
    assert!(output_str.contains("--fail-on-scan"));
}

#[test]
#[serial]
fn test_scan_without_docker_env_var() {
    // Create a temporary directory with a simple test setup
    let temp_dir = TempDir::new().unwrap();

    // Create a minimal devcontainer.json - this will fail to build but allows testing argument parsing
    let devcontainer_config = r#"{
    "name": "Test Container", 
    "image": "alpine:3.19"
}
"#;

    std::fs::create_dir(temp_dir.path().join(".devcontainer")).unwrap();
    std::fs::write(
        temp_dir.path().join(".devcontainer/devcontainer.json"),
        devcontainer_config,
    )
    .unwrap();

    // Ensure DEACON_SCAN_CMD is not set
    env::remove_var("DEACON_SCAN_CMD");

    // Test build command with scan flags - this should fail due to no dockerfile/image build capability
    // but it validates that the flags are parsed correctly
    let mut cmd = Command::cargo_bin("deacon").unwrap();
    cmd.current_dir(&temp_dir)
        .arg("build")
        .arg("--scan-image")
        .arg("--fail-on-scan");

    // The command should fail but not due to flag parsing issues
    cmd.assert()
        .failure()
        // clap uses exit code 2 for argument parsing failures; ensure we reached build logic
        .code(predicate::ne(2))
        // Assert the failure is related to Docker/build issues, not flag rejection
        .stderr(
            predicate::str::contains("Cannot build with 'image' configuration")
                .or(predicate::str::contains("Docker").or(predicate::str::contains("docker"))),
        );
}

#[test]
#[serial]
fn test_fail_on_scan_requires_scan_image() {
    // Test that --fail-on-scan requires --scan-image
    let mut cmd = Command::cargo_bin("deacon").unwrap();
    cmd.arg("build").arg("--fail-on-scan");

    cmd.assert()
        .failure()
        .code(2) // clap uses exit code 2 for argument parsing failures
        .stderr(predicate::str::contains("--scan-image"));
}

/// Test token substitution function directly via unit tests
#[cfg(test)]
mod unit_tests {
    use deacon::commands::build::substitute_tokens;

    #[test]
    fn test_token_substitution_direct() {
        let template = "trivy image {image}";
        let image_id = "sha256:abc123def456";
        let result = substitute_tokens(template, image_id).unwrap();
        assert_eq!(result, "trivy image sha256:abc123def456");

        // Test with multiple occurrences
        let template = "scanner --image {image} --output /tmp/{image}.json";
        let result = substitute_tokens(template, image_id).unwrap();
        assert_eq!(
            result,
            "scanner --image sha256:abc123def456 --output /tmp/sha256:abc123def456.json"
        );
    }
}
