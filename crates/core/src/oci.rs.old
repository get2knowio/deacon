//! OCI registry integration for DevContainer features
//!
//! This module implements OCI registry v2 support with authentication for fetching
//! and installing DevContainer features. It supports authentication via environment
//! variables, Docker credential helpers, custom CA certificates, and proxy configuration.
//!
//! ## Core Capabilities
//!
//! - **Feature and Template Operations**: Fetch, install, and publish features and templates
//! - **Tag Listing**: Query available tags from registries (`list_tags`)
//! - **Manifest Operations**: Fetch manifests by tag or digest (`get_manifest`, `get_manifest_by_digest`)
//! - **Multi-Tag Publishing**: Publish artifacts with multiple tags in one operation (`publish_feature_multi_tag`)
//! - **Collection Metadata**: Support for devcontainer-collection.json structure
//! - **Semantic Versioning**: Parse, filter, sort, and compute semantic version tags (`semver_utils` module)
//!
//! ## Authentication
//!
//! Supports multiple authentication methods with the following precedence order:
//!
//! 1. **Environment Variables** (highest priority):
//!    - `DEACON_REGISTRY_TOKEN`: Bearer token authentication
//!    - `DEACON_REGISTRY_USER` + `DEACON_REGISTRY_PASS`: Basic authentication
//! 2. **Docker config.json**: Credentials from `~/.docker/config.json`
//! 3. **No authentication**: Fallback for public registries
//!
//! Custom CA certificates can be configured via:
//! - `DEACON_CUSTOM_CA_BUNDLE`: Path to a PEM-encoded CA certificate bundle
//!
//! ## Semantic Version Utilities
//!
//! The `semver_utils` module provides utilities for working with semantic versions:
//! - Parse versions from tags (handles "v1.2.3", "1.2.3", "1.2", "1" formats)
//! - Filter tags to only semantic versions
//! - Sort tags in semantic version order
//! - Compute semantic tags (e.g., "1.2.3" â†’ ["1", "1.2", "1.2.3", "latest"])
//! - Compare versions

use crate::errors::{FeatureError, Result};
use crate::features::{parse_feature_metadata, FeatureMetadata};
use crate::progress::{ProgressEvent, ProgressTracker};
use crate::redaction;
use crate::retry::{retry_async, RetryConfig, RetryDecision};
use base64::Engine;
use bytes::Bytes;
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use std::collections::HashMap;
use std::env;
use std::fs;
use std::path::{Path, PathBuf};
use std::sync::Arc;
use std::time::{Duration, Instant, SystemTime, UNIX_EPOCH};
use tar::Archive;
use tokio::sync::Mutex;
use tracing::{debug, info, instrument, warn};

/// Reference to a feature in an OCI registry
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct FeatureRef {
    /// Registry hostname (e.g., "ghcr.io")
    pub registry: String,
    /// Namespace (e.g., "devcontainers")
    pub namespace: String,
    /// Feature name (e.g., "node")
    pub name: String,
    /// Version (optional, defaults to "latest")
    pub version: Option<String>,
}

/// Reference to a template in an OCI registry
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TemplateRef {
    /// Registry hostname (e.g., "ghcr.io")
    pub registry: String,
    /// Namespace (e.g., "devcontainers")
    pub namespace: String,
    /// Template name (e.g., "python")
    pub name: String,
    /// Version (optional, defaults to "latest")
    pub version: Option<String>,
}

impl FeatureRef {
    /// Create a new FeatureRef
    pub fn new(registry: String, namespace: String, name: String, version: Option<String>) -> Self {
        Self {
            registry,
            namespace,
            name,
            version,
        }
    }

    /// Get the tag for this feature reference
    pub fn tag(&self) -> &str {
        self.version.as_deref().unwrap_or("latest")
    }

    /// Get the repository name for this feature
    pub fn repository(&self) -> String {
        format!("{}/{}", self.namespace, self.name)
    }

    /// Get the full reference string
    pub fn reference(&self) -> String {
        format!("{}/{}:{}", self.registry, self.repository(), self.tag())
    }
}

impl TemplateRef {
    /// Create a new TemplateRef
    pub fn new(registry: String, namespace: String, name: String, version: Option<String>) -> Self {
        Self {
            registry,
            namespace,
            name,
            version,
        }
    }

    /// Get the tag for this template reference
    pub fn tag(&self) -> &str {
        self.version.as_deref().unwrap_or("latest")
    }

    /// Get the repository name for this template
    pub fn repository(&self) -> String {
        format!("{}/{}", self.namespace, self.name)
    }

    /// Get the full reference string
    pub fn reference(&self) -> String {
        format!("{}/{}:{}", self.registry, self.repository(), self.tag())
    }
}

/// Authentication credentials for registry access
#[derive(Debug, Clone, PartialEq)]
pub enum RegistryCredentials {
    /// No authentication
    None,
    /// Basic authentication with username and password
    Basic { username: String, password: String },
    /// Bearer token authentication
    Bearer { token: String },
}

impl RegistryCredentials {
    /// Create an Authorization header value
    pub fn to_auth_header(&self) -> Option<String> {
        match self {
            RegistryCredentials::None => None,
            RegistryCredentials::Basic { username, password } => {
                let credentials = format!("{}:{}", username, password);
                let encoded = base64::engine::general_purpose::STANDARD.encode(credentials);
                Some(format!("Basic {}", encoded))
            }
            RegistryCredentials::Bearer { token } => Some(format!("Bearer {}", token)),
        }
    }
}

/// Registry authentication configuration
#[derive(Debug, Clone)]
pub struct RegistryAuth {
    /// Default credentials to use for all registries
    pub default_credentials: RegistryCredentials,
    /// Registry-specific credentials
    pub registry_credentials: HashMap<String, RegistryCredentials>,
}

impl RegistryAuth {
    /// Create a new empty registry auth configuration
    pub fn new() -> Self {
        Self {
            default_credentials: RegistryCredentials::None,
            registry_credentials: HashMap::new(),
        }
    }

    /// Get credentials for a specific registry
    pub fn get_credentials(&self, registry: &str) -> &RegistryCredentials {
        self.registry_credentials
            .get(registry)
            .unwrap_or(&self.default_credentials)
    }

    /// Set credentials for a specific registry
    pub fn set_credentials(&mut self, registry: String, credentials: RegistryCredentials) {
        self.registry_credentials.insert(registry, credentials);
    }

    /// Set default credentials
    pub fn set_default_credentials(&mut self, credentials: RegistryCredentials) {
        self.default_credentials = credentials;
    }
}

impl Default for RegistryAuth {
    fn default() -> Self {
        Self::new()
    }
}

/// Docker config.json authentication entry
#[derive(Debug, Deserialize)]
struct DockerConfigAuth {
    auth: Option<String>,
    username: Option<String>,
    password: Option<String>,
}

/// Docker config.json structure (simplified)
#[derive(Debug, Deserialize)]
struct DockerConfig {
    auths: Option<HashMap<String, DockerConfigAuth>>,
}

/// Downloaded and extracted feature data
#[derive(Debug, Clone)]
pub struct DownloadedFeature {
    /// Extracted feature directory
    pub path: PathBuf,
    /// Feature metadata
    pub metadata: FeatureMetadata,
    /// Feature digest for caching
    pub digest: String,
}

/// Downloaded and extracted template data
#[derive(Debug)]
pub struct DownloadedTemplate {
    /// Extracted template directory
    pub path: PathBuf,
    /// Template metadata
    pub metadata: crate::templates::TemplateMetadata,
    /// Template digest for caching
    pub digest: String,
}

/// Result of publishing an artifact to an OCI registry
#[derive(Debug, Clone)]
pub struct PublishResult {
    /// Registry URL where the artifact was published
    pub registry: String,
    /// Repository name
    pub repository: String,
    /// Tag used for publishing
    pub tag: String,
    /// Digest of the published manifest
    pub digest: String,
    /// Size of the published artifact in bytes
    pub size: u64,
}

/// OCI manifest structure (minimal)
#[derive(Debug, Deserialize, Serialize)]
#[allow(dead_code)]
pub struct Manifest {
    #[serde(rename = "schemaVersion")]
    pub schema_version: u32,
    #[serde(rename = "mediaType")]
    pub media_type: String,
    pub layers: Vec<Layer>,
}

/// OCI layer structure (minimal)
#[derive(Debug, Deserialize, Serialize)]
#[allow(dead_code)]
pub struct Layer {
    #[serde(rename = "mediaType")]
    pub media_type: String,
    pub size: u64,
    pub digest: String,
}

/// OCI tag list response structure
#[derive(Debug, Deserialize, Serialize)]
pub struct TagList {
    /// Repository name
    pub name: String,
    /// List of tags
    pub tags: Vec<String>,
}

/// DevContainer collection metadata structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CollectionMetadata {
    /// Source information (e.g., GitHub repository)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source_information: Option<CollectionSourceInfo>,
    /// List of features in the collection
    #[serde(skip_serializing_if = "Option::is_none")]
    pub features: Option<Vec<CollectionFeature>>,
    /// List of templates in the collection
    #[serde(skip_serializing_if = "Option::is_none")]
    pub templates: Option<Vec<CollectionTemplate>>,
}

/// Source information for a collection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CollectionSourceInfo {
    /// Source provider (e.g., "github")
    pub provider: String,
    /// Repository or source identifier
    pub repository: String,
}

/// Feature entry in a collection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CollectionFeature {
    /// Feature identifier
    pub id: String,
    /// Feature version
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
    /// Feature name
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Feature description
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}

/// Template entry in a collection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CollectionTemplate {
    /// Template identifier
    pub id: String,
    /// Template version
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
    /// Template name
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Template description
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}

/// HTTP response with status, headers, and body
#[derive(Debug, Clone)]
pub struct HttpResponse {
    pub status: u16,
    pub headers: HashMap<String, String>,
    pub body: Bytes,
}

#[async_trait::async_trait]
pub trait HttpClient: Send + Sync {
    /// Perform a GET request and return the response body
    async fn get(
        &self,
        url: &str,
    ) -> std::result::Result<Bytes, Box<dyn std::error::Error + Send + Sync>>;

    /// Get with custom headers
    async fn get_with_headers(
        &self,
        url: &str,
        headers: HashMap<String, String>,
    ) -> std::result::Result<Bytes, Box<dyn std::error::Error + Send + Sync>>;

    /// GET with custom headers that returns full response including headers (for pagination)
    async fn get_with_headers_and_response(
        &self,
        url: &str,
        headers: HashMap<String, String>,
    ) -> std::result::Result<HttpResponse, Box<dyn std::error::Error + Send + Sync>>;

    /// HEAD request to check resource existence without downloading body
    async fn head(
        &self,
        url: &str,
        headers: HashMap<String, String>,
    ) -> std::result::Result<u16, Box<dyn std::error::Error + Send + Sync>>;

    /// PUT request with data and headers
    async fn put_with_headers(
        &self,
        url: &str,
        data: Bytes,
        headers: HashMap<String, String>,
    ) -> std::result::Result<Bytes, Box<dyn std::error::Error + Send + Sync>>;

    /// POST request with data and headers, returns full response with headers
    async fn post_with_headers(
        &self,
        url: &str,
        data: Bytes,
        headers: HashMap<String, String>,
    ) -> std::result::Result<HttpResponse, Box<dyn std::error::Error + Send + Sync>>;
}

/// Default HTTP client implementation using reqwest
#[derive(Debug, Clone)]
pub struct ReqwestClient {
    client: reqwest::Client,
    auth: RegistryAuth,
}

impl ReqwestClient {
    /// Create a new ReqwestClient with default configuration (no timeout)
    pub fn new() -> std::result::Result<Self, Box<dyn std::error::Error + Send + Sync>> {
        Self::with_timeout(None)
    }

    /// Parse WWW-Authenticate header and exchange for token
    ///
    /// Implements OCI Distribution Spec token authentication for anonymous access.
    /// Parses the Bearer challenge from WWW-Authenticate header and exchanges for a token.
    async fn exchange_token(
        &self,
        www_authenticate: &str,
    ) -> std::result::Result<String, Box<dyn std::error::Error + Send + Sync>> {
        // Parse Bearer challenge: Bearer realm="...",service="...",scope="..."
        let mut realm = None;
        let mut service = None;
        let mut scope = None;

        // Simple parser for Bearer challenge parameters
        if let Some(bearer_params) = www_authenticate.strip_prefix("Bearer ") {
            for param in bearer_params.split(',') {
                let param = param.trim();
                if let Some((key, value)) = param.split_once('=') {
                    let value = value.trim_matches('"');
                    match key {
                        "realm" => realm = Some(value.to_string()),
                        "service" => service = Some(value.to_string()),
                        "scope" => scope = Some(value.to_string()),
                        _ => {}
                    }
                }
            }
        }

        let realm = realm.ok_or("Missing realm in WWW-Authenticate header")?;

        // Build token URL
        let mut token_url = realm;
        let mut params = Vec::new();
        if let Some(service) = service {
            params.push(format!("service={}", service));
        }
        if let Some(scope) = scope {
            params.push(format!("scope={}", scope));
        }
        if !params.is_empty() {
            token_url.push('?');
            token_url.push_str(&params.join("&"));
        }

        debug!("Exchanging for anonymous token at: {}", token_url);

        // Make token request (anonymous - no credentials)
        let response = self.client.get(&token_url).send().await?;

        if !response.status().is_success() {
            return Err(format!("Token exchange failed with status: {}", response.status()).into());
        }

        let token_response: serde_json::Value = response.json().await?;

        // Extract token from response
        let token = token_response
            .get("token")
            .or_else(|| token_response.get("access_token"))
            .and_then(|t| t.as_str())
            .ok_or("Token not found in response")?
            .to_string();

        debug!("Successfully obtained anonymous access token");
        Ok(token)
    }

    /// Create a new ReqwestClient with custom timeout configuration
    ///
    /// # Arguments
    /// * `timeout` - Optional timeout for all requests. If None, no timeout is applied.
    ///
    /// # Examples
    /// ```
    /// use deacon_core::oci::ReqwestClient;
    /// use std::time::Duration;
    ///
    /// // Create client with 2 second timeout
    /// let client = ReqwestClient::with_timeout(Some(Duration::from_secs(2)));
    /// ```
    pub fn with_timeout(
        timeout: Option<Duration>,
    ) -> std::result::Result<Self, Box<dyn std::error::Error + Send + Sync>> {
        let mut client_builder = reqwest::Client::builder();

        // Configure timeout if specified
        if let Some(timeout_duration) = timeout {
            client_builder = client_builder.timeout(timeout_duration);
            debug!(
                "Configured HTTP client with timeout: {:?}",
                timeout_duration
            );
        }

        // Configure custom CA certificates if specified
        if let Ok(ca_bundle_path) = env::var("DEACON_CUSTOM_CA_BUNDLE") {
            let ca_bundle = fs::read(&ca_bundle_path)?;
            let cert = reqwest::Certificate::from_pem(&ca_bundle)?;
            client_builder = client_builder.add_root_certificate(cert);
            debug!("Added custom CA certificate from: {}", ca_bundle_path);
        }

        // Build the client
        let client = client_builder.build()?;

        let mut auth = RegistryAuth::new();

        // Load authentication from environment and Docker config
        Self::load_auth_from_env(&mut auth)?;
        Self::load_auth_from_docker_config(&mut auth)?;

        Ok(Self { client, auth })
    }

    /// Create a new ReqwestClient with custom authentication configuration
    pub fn with_auth_config(
        auth: RegistryAuth,
    ) -> std::result::Result<Self, Box<dyn std::error::Error + Send + Sync>> {
        let client_builder = reqwest::Client::builder();

        // Note: We don't load custom CA certificates here since this method is for explicit config
        // If CA certificates are needed, they should be handled by the caller

        // Build the client
        let client = client_builder.build()?;

        Ok(Self { client, auth })
    }

    /// Load authentication from environment variables
    ///
    /// This function loads authentication credentials from environment variables with the following priority:
    /// 1. `DEACON_REGISTRY_TOKEN` - Bearer token authentication (highest priority)
    /// 2. `DEACON_REGISTRY_USER` + `DEACON_REGISTRY_PASS` - Basic authentication
    ///
    /// # Security Notes
    /// - All sensitive values (tokens, passwords) are automatically added to the global redaction registry
    /// - Redacted values will not appear in logs, error messages, or any output
    /// - This prevents accidental leakage of credentials in debugging or error scenarios
    fn load_auth_from_env(
        auth: &mut RegistryAuth,
    ) -> std::result::Result<(), Box<dyn std::error::Error + Send + Sync>> {
        // Check for token authentication first
        if let Ok(token) = env::var("DEACON_REGISTRY_TOKEN") {
            debug!("Found DEACON_REGISTRY_TOKEN environment variable");
            // Add token to redaction registry
            redaction::add_global_secret(&token);
            auth.set_default_credentials(RegistryCredentials::Bearer { token });
            return Ok(());
        }

        // Check for basic authentication
        if let (Ok(username), Ok(password)) = (
            env::var("DEACON_REGISTRY_USER"),
            env::var("DEACON_REGISTRY_PASS"),
        ) {
            debug!("Found DEACON_REGISTRY_USER and DEACON_REGISTRY_PASS environment variables");
            // Add password to redaction registry
            redaction::add_global_secret(&password);
            auth.set_default_credentials(RegistryCredentials::Basic { username, password });
        }

        Ok(())
    }

    /// Load authentication from Docker config.json
    ///
    /// This function loads authentication credentials from Docker's config.json file
    /// located at `~/.docker/config.json` (or `%USERPROFILE%\.docker\config.json` on Windows).
    ///
    /// Supports both encoded auth strings and separate username/password fields.
    /// Registry-specific credentials override default credentials.
    ///
    /// # Security Notes
    /// - Passwords extracted from Docker config are treated as sensitive
    /// - All credential values are automatically redacted in logs and error messages
    /// - This follows Docker's standard credential handling practices
    fn load_auth_from_docker_config(
        auth: &mut RegistryAuth,
    ) -> std::result::Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let home_dir = env::var("HOME").or_else(|_| env::var("USERPROFILE"))?;
        let docker_config_path = Path::new(&home_dir).join(".docker").join("config.json");

        if !docker_config_path.exists() {
            debug!(
                "Docker config.json not found at: {}",
                docker_config_path.display()
            );
            return Ok(());
        }

        let config_content = fs::read_to_string(&docker_config_path)?;
        let docker_config: DockerConfig = serde_json::from_str(&config_content)?;

        if let Some(auths) = docker_config.auths {
            for (registry, auth_config) in auths {
                if let Some(auth_string) = auth_config.auth {
                    // Decode base64 auth string
                    if let Ok(decoded) =
                        base64::engine::general_purpose::STANDARD.decode(&auth_string)
                    {
                        if let Ok(auth_str) = String::from_utf8(decoded) {
                            if let Some((username, password)) = auth_str.split_once(':') {
                                debug!("Loaded Docker config auth for registry: {}", registry);
                                auth.set_credentials(
                                    registry,
                                    RegistryCredentials::Basic {
                                        username: username.to_string(),
                                        password: password.to_string(),
                                    },
                                );
                            }
                        }
                    }
                } else if let (Some(username), Some(password)) =
                    (auth_config.username, auth_config.password)
                {
                    debug!(
                        "Loaded Docker config username/password for registry: {}",
                        registry
                    );
                    auth.set_credentials(
                        registry,
                        RegistryCredentials::Basic { username, password },
                    );
                }
            }
        }

        Ok(())
    }

    /// Get credentials for a specific registry URL
    fn get_credentials_for_url(&self, url: &str) -> &RegistryCredentials {
        // Extract hostname from URL
        if let Ok(parsed_url) = reqwest::Url::parse(url) {
            if let Some(host) = parsed_url.host_str() {
                return self.auth.get_credentials(host);
            }
        }
        &self.auth.default_credentials
    }

    /// Get access to the authentication configuration (for testing)
    pub fn auth(&self) -> &RegistryAuth {
        &self.auth
    }
}

impl Default for ReqwestClient {
    fn default() -> Self {
        Self::new().unwrap_or_else(|e| {
            warn!(
                "Failed to create ReqwestClient with authentication: {}. Using basic client.",
                e
            );
            Self {
                client: reqwest::Client::new(),
                auth: RegistryAuth::new(),
            }
        })
    }
}

#[async_trait::async_trait]
impl HttpClient for ReqwestClient {
    async fn get(
        &self,
        url: &str,
    ) -> std::result::Result<Bytes, Box<dyn std::error::Error + Send + Sync>> {
        self.get_with_headers(url, HashMap::new()).await
    }

    async fn get_with_headers(
        &self,
        url: &str,
        mut headers: HashMap<String, String>,
    ) -> std::result::Result<Bytes, Box<dyn std::error::Error + Send + Sync>> {
        // Add authentication header if available
        let credentials = self.get_credentials_for_url(url);
        if let Some(auth_header) = credentials.to_auth_header() {
            headers.insert("Authorization".to_string(), auth_header);
        }

        let mut request = self.client.get(url);
        for (key, value) in &headers {
            request = request.header(key, value);
        }

        let response = request.send().await.map_err(|e| {
            // Improve error messages for common network issues
            if e.is_timeout() {
                format!("Request timeout for URL: {}. Check network connectivity.", url)
            } else if e.is_connect() {
                format!(
                    "Connection failed for URL: {}. Check if the registry is accessible and network connectivity is available.",
                    url
                )
            } else if e.is_request() {
                format!("Request error for URL: {}: {}", url, e)
            } else {
                format!("Network error for URL: {}: {}", url, e)
            }
        })?;

        // Handle 401 authentication errors with token exchange
        if response.status() == reqwest::StatusCode::UNAUTHORIZED {
            // Try to get WWW-Authenticate header for token exchange
            if let Some(www_auth) = response.headers().get("www-authenticate") {
                if let Ok(www_auth_str) = www_auth.to_str() {
                    if www_auth_str.starts_with("Bearer ") {
                        debug!("Got 401 with Bearer challenge, attempting token exchange");

                        // Attempt token exchange for anonymous access
                        if let Ok(token) = self.exchange_token(www_auth_str).await {
                            // Retry request with the obtained token
                            let mut retry_headers = headers.clone();
                            retry_headers
                                .insert("Authorization".to_string(), format!("Bearer {}", token));

                            let mut retry_request = self.client.get(url);
                            for (key, value) in retry_headers {
                                retry_request = retry_request.header(&key, &value);
                            }

                            let retry_response = retry_request.send().await?;

                            if retry_response.status().is_success() {
                                return Ok(retry_response.bytes().await?);
                            }
                        }
                    }
                }
            }

            return Err(format!("Authentication failed for URL: {}", url).into());
        }

        // Handle other HTTP errors
        if !response.status().is_success() {
            return Err(format!("HTTP {} for URL: {}", response.status(), url).into());
        }

        let bytes = response.bytes().await?;
        Ok(bytes)
    }

    async fn get_with_headers_and_response(
        &self,
        url: &str,
        mut headers: HashMap<String, String>,
    ) -> std::result::Result<HttpResponse, Box<dyn std::error::Error + Send + Sync>> {
        // Add authentication header if available
        let credentials = self.get_credentials_for_url(url);
        if let Some(auth_header) = credentials.to_auth_header() {
            headers.insert("Authorization".to_string(), auth_header);
        }

        let mut request = self.client.get(url);
        for (key, value) in &headers {
            request = request.header(key, value);
        }

        let response = request.send().await.map_err(|e| {
            // Improve error messages for common network issues
            if e.is_timeout() {
                format!("Request timeout for URL: {}. Check network connectivity.", url)
            } else if e.is_connect() {
                format!(
                    "Connection failed for URL: {}. Check if the registry is accessible and network connectivity is available.",
                    url
                )
            } else if e.is_request() {
                format!("Request error for URL: {}: {}", url, e)
            } else {
                format!("Network error for URL: {}: {}", url, e)
            }
        })?;

        // Handle 401 authentication errors with token exchange
        if response.status() == reqwest::StatusCode::UNAUTHORIZED {
            // Try to get WWW-Authenticate header for token exchange
            if let Some(www_auth) = response.headers().get("www-authenticate") {
                if let Ok(www_auth_str) = www_auth.to_str() {
                    if www_auth_str.starts_with("Bearer ") {
                        debug!("Got 401 with Bearer challenge, attempting token exchange");

                        // Attempt token exchange for anonymous access
                        if let Ok(token) = self.exchange_token(www_auth_str).await {
                            // Retry request with the obtained token
                            let mut retry_headers = headers.clone();
                            retry_headers
                                .insert("Authorization".to_string(), format!("Bearer {}", token));

                            let mut retry_request = self.client.get(url);
                            for (key, value) in &retry_headers {
                                retry_request = retry_request.header(key, value);
                            }

                            let retry_response = retry_request.send().await?;
                            let status = retry_response.status().as_u16();

                            // Extract headers from retry response
                            let mut response_headers = HashMap::new();
                            for (key, value) in retry_response.headers() {
                                if let Ok(value_str) = value.to_str() {
                                    response_headers.insert(key.to_string(), value_str.to_string());
                                }
                            }

                            if retry_response.status().is_success() {
                                let bytes = retry_response.bytes().await?;
                                return Ok(HttpResponse {
                                    status,
                                    headers: response_headers,
                                    body: bytes,
                                });
                            }
                        }
                    }
                }
            }

            return Err(format!("Authentication failed for URL: {}", url).into());
        }

        let status = response.status().as_u16();

        // Extract headers
        let mut response_headers = HashMap::new();
        for (key, value) in response.headers() {
            if let Ok(value_str) = value.to_str() {
                response_headers.insert(key.to_string(), value_str.to_string());
            }
        }

        // Handle other HTTP errors
        if !response.status().is_success() {
            return Err(format!("HTTP {} for URL: {}", response.status(), url).into());
        }

        let bytes = response.bytes().await?;
        Ok(HttpResponse {
            status,
            headers: response_headers,
            body: bytes,
        })
    }

    async fn head(
        &self,
        url: &str,
        mut headers: HashMap<String, String>,
    ) -> std::result::Result<u16, Box<dyn std::error::Error + Send + Sync>> {
        // Add authentication header if available
        let credentials = self.get_credentials_for_url(url);
        if let Some(auth_header) = credentials.to_auth_header() {
            headers.insert("Authorization".to_string(), auth_header);
        }

        let mut request = self.client.head(url);
        for (key, value) in headers {
            request = request.header(&key, &value);
        }

        let response = request.send().await.map_err(|e| {
            // Improve error messages for common network issues
            if e.is_timeout() {
                format!("Request timeout for URL: {}. Check network connectivity.", url)
            } else if e.is_connect() {
                format!(
                    "Connection failed for URL: {}. Check if the registry is accessible and network connectivity is available.",
                    url
                )
            } else if e.is_request() {
                format!("Request error for URL: {}: {}", url, e)
            } else {
                format!("Network error for URL: {}: {}", url, e)
            }
        })?;

        Ok(response.status().as_u16())
    }

    async fn put_with_headers(
        &self,
        url: &str,
        data: Bytes,
        mut headers: HashMap<String, String>,
    ) -> std::result::Result<Bytes, Box<dyn std::error::Error + Send + Sync>> {
        // Add authentication header if available
        let credentials = self.get_credentials_for_url(url);
        if let Some(auth_header) = credentials.to_auth_header() {
            headers.insert("Authorization".to_string(), auth_header);
        }

        let mut request = self.client.put(url).body(data);
        for (key, value) in headers {
            request = request.header(&key, &value);
        }

        let response = request.send().await.map_err(|e| {
            // Improve error messages for common network issues
            if e.is_timeout() {
                format!("Request timeout for URL: {}. Check network connectivity.", url)
            } else if e.is_connect() {
                format!(
                    "Connection failed for URL: {}. Check if the registry is accessible and network connectivity is available.",
                    url
                )
            } else if e.is_request() {
                format!("Request error for URL: {}: {}", url, e)
            } else {
                format!("Network error for URL: {}: {}", url, e)
            }
        })?;

        // Handle 401 authentication errors
        if response.status() == reqwest::StatusCode::UNAUTHORIZED {
            return Err(format!("Authentication failed for URL: {}", url).into());
        }

        // Handle other HTTP errors
        if !response.status().is_success() {
            return Err(format!("HTTP {} for URL: {}", response.status(), url).into());
        }

        let bytes = response.bytes().await?;
        Ok(bytes)
    }

    async fn post_with_headers(
        &self,
        url: &str,
        data: Bytes,
        mut headers: HashMap<String, String>,
    ) -> std::result::Result<HttpResponse, Box<dyn std::error::Error + Send + Sync>> {
        // Add authentication header if available
        let credentials = self.get_credentials_for_url(url);
        if let Some(auth_header) = credentials.to_auth_header() {
            headers.insert("Authorization".to_string(), auth_header);
        }

        let mut request = self.client.post(url).body(data);
        for (key, value) in headers {
            request = request.header(&key, &value);
        }

        let response = request.send().await.map_err(|e| {
            // Improve error messages for common network issues
            if e.is_timeout() {
                format!("Request timeout for URL: {}. Check network connectivity.", url)
            } else if e.is_connect() {
                format!(
                    "Connection failed for URL: {}. Check if the registry is accessible and network connectivity is available.",
                    url
                )
            } else if e.is_request() {
                format!("Request error for URL: {}: {}", url, e)
            } else {
                format!("Network error for URL: {}: {}", url, e)
            }
        })?;

        let status = response.status().as_u16();

        // Extract headers
        let mut response_headers = HashMap::new();
        for (key, value) in response.headers() {
            if let Ok(value_str) = value.to_str() {
                response_headers.insert(key.to_string(), value_str.to_string());
            }
        }

        // Handle 401 authentication errors
        if response.status() == reqwest::StatusCode::UNAUTHORIZED {
            return Err(format!("Authentication failed for URL: {}", url).into());
        }

        // Handle other HTTP errors
        if !response.status().is_success() {
            return Err(format!("HTTP {} for URL: {}", response.status(), url).into());
        }

        let bytes = response.bytes().await?;
        Ok(HttpResponse {
            status,
            headers: response_headers,
            body: bytes,
        })
    }
}

/// Feature fetcher for OCI registries
pub struct FeatureFetcher<C: HttpClient> {
    client: C,
    cache_dir: PathBuf,
    retry_config: RetryConfig,
    progress_tracker: Arc<Mutex<Option<ProgressTracker>>>,
}

/// Error classifier for network operations
/// Only retries on network-related errors, not on parsing or other logical errors
fn classify_network_error(error: &FeatureError) -> RetryDecision {
    match error {
        FeatureError::Download { .. } => RetryDecision::Retry,
        FeatureError::Oci { .. } => RetryDecision::Retry,
        // Authentication errors should be retried once to allow credential refresh
        FeatureError::Authentication { .. } => RetryDecision::Retry,
        // Don't retry auth failures - they require correct credentials
        FeatureError::Unauthorized { .. } | FeatureError::Forbidden { .. } => RetryDecision::Stop,
        // Don't retry parsing, validation, or other logical errors
        FeatureError::Parsing { .. }
        | FeatureError::Validation { .. }
        | FeatureError::Extraction { .. }
        | FeatureError::Installation { .. }
        | FeatureError::InstallationFailed { .. }
        | FeatureError::NotFound { .. }
        | FeatureError::DependencyCycle { .. }
        | FeatureError::InvalidDependency { .. }
        | FeatureError::DependencyResolution { .. } => RetryDecision::Stop,
        // For IO errors, retry as they might be transient
        FeatureError::Io(_) => RetryDecision::Retry,
        FeatureError::Json(_) => RetryDecision::Stop,
        FeatureError::NotImplemented => RetryDecision::Stop,
    }
}

/// Get the default cache directory for features
///
/// Uses the standard cache directory with a 'features' subdirectory for persistent
/// feature caching across workspace sessions.
///
/// # Examples
///
/// ```
/// use deacon_core::oci::get_features_cache_dir;
/// let cache_dir = get_features_cache_dir().expect("failed to get features cache dir");
/// assert!(cache_dir.ends_with("features"));
/// ```
pub fn get_features_cache_dir() -> Result<PathBuf> {
    let base_cache = crate::progress::get_cache_dir().map_err(|e| FeatureError::Oci {
        message: format!("Failed to get cache directory: {}", e),
    })?;
    let features_cache = base_cache.join("features");

    // Ensure features cache directory exists
    if !features_cache.exists() {
        std::fs::create_dir_all(&features_cache).map_err(|e| FeatureError::Oci {
            message: format!("Failed to create features cache directory: {}", e),
        })?;
    }

    Ok(features_cache)
}

/// Compute the canonical ID (SHA256 digest) of an OCI manifest
///
/// The canonical ID is the SHA256 hash of the manifest's serialized JSON representation.
/// This serves as a unique, content-addressed identifier for the manifest in OCI registries.
///
/// # Arguments
///
/// * `manifest` - The OCI manifest to compute the canonical ID for
///
/// # Returns
///
/// A string in the format `sha256:<64-character-hex-digest>`
///
/// # Examples
///
/// ```
/// use deacon_core::oci::{Manifest, canonical_id};
/// use serde_json::json;
///
/// // Note: This example assumes Manifest can be constructed from JSON
/// let manifest_json = json!({
///     "schemaVersion": 2,
///     "mediaType": "application/vnd.oci.image.manifest.v1+json",
///     "layers": []
/// });
/// // In practice, manifests are parsed from OCI registry responses
/// ```
pub fn canonical_id(manifest: &Manifest) -> Result<String> {
    let manifest_json = serde_json::to_vec(manifest).map_err(FeatureError::Json)?;
    let mut hasher = Sha256::new();
    hasher.update(&manifest_json);
    Ok(format!("sha256:{:x}", hasher.finalize()))
}

impl<C: HttpClient> FeatureFetcher<C> {
    /// Create a new FeatureFetcher with custom HTTP client
    pub fn new(client: C) -> Self {
        let cache_dir = get_features_cache_dir().unwrap_or_else(|_| {
            // Fallback to temp directory if persistent cache fails
            std::env::temp_dir().join("deacon-features")
        });
        Self {
            client,
            cache_dir,
            retry_config: RetryConfig::default(),
            progress_tracker: Arc::new(Mutex::new(None)),
        }
    }

    /// Create a new FeatureFetcher with custom cache directory
    pub fn with_cache_dir(client: C, cache_dir: PathBuf) -> Self {
        Self {
            client,
            cache_dir,
            retry_config: RetryConfig::default(),
            progress_tracker: Arc::new(Mutex::new(None)),
        }
    }

    /// Create a new FeatureFetcher with custom retry configuration
    pub fn with_retry_config(client: C, cache_dir: PathBuf, retry_config: RetryConfig) -> Self {
        Self {
            client,
            cache_dir,
            retry_config,
            progress_tracker: Arc::new(Mutex::new(None)),
        }
    }

    /// Set progress tracker for emitting events
    pub async fn set_progress_tracker(&self, tracker: ProgressTracker) {
        let mut progress = self.progress_tracker.lock().await;
        *progress = Some(tracker);
    }

    /// Emit a progress event if a tracker is configured
    async fn emit_progress_event(&self, event: ProgressEvent) {
        if let Some(ref mut tracker) = self.progress_tracker.lock().await.as_mut() {
            if let Err(e) = tracker.emit_event(event) {
                warn!("Failed to emit progress event: {}", e);
            }
        }
    }

    /// Get a reference to the HTTP client (for testing)
    pub fn client(&self) -> &C {
        &self.client
    }

    /// Fetch a feature from an OCI registry
    #[instrument(level = "info", skip(self))]
    pub async fn fetch_feature(&self, feature_ref: &FeatureRef) -> Result<DownloadedFeature> {
        let start_time = Instant::now();
        let event_id =
            crate::progress::EVENT_ID_COUNTER.fetch_add(1, std::sync::atomic::Ordering::SeqCst);
        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64;

        // Emit fetch begin event
        self.emit_progress_event(ProgressEvent::OciFetchBegin {
            id: event_id,
            timestamp,
            registry: feature_ref.registry.clone(),
            repository: feature_ref.repository(),
            tag: feature_ref.tag().to_string(),
        })
        .await;

        info!("Fetching feature: {}", feature_ref.reference());

        let result = async {
            // Get the manifest
            let manifest = self.get_manifest(feature_ref).await.map_err(|e| match e {
                crate::errors::DeaconError::Feature(f) => f,
                _ => FeatureError::Oci {
                    message: format!("Get manifest error: {}", e),
                },
            })?;
            debug!("Got manifest with {} layers", manifest.layers.len());

            // For now, assume single tar layer (as per requirements)
            if manifest.layers.is_empty() {
                return Err(FeatureError::Oci {
                    message: "No layers found in manifest".to_string(),
                });
            }

            let layer = &manifest.layers[0];
            debug!("Using layer: digest={}, size={}", layer.digest, layer.size);

            // Check cache first
            let cache_key = self.get_cache_key(&layer.digest);
            let cached_dir = self.cache_dir.join(&cache_key);

            let is_cached = cached_dir.exists();
            if is_cached {
                info!("Found cached feature at: {}", cached_dir.display());
                let feature = self
                    .load_cached_feature(cached_dir, layer.digest.clone())
                    .await
                    .map_err(|e| match e {
                        crate::errors::DeaconError::Feature(f) => f,
                        _ => FeatureError::Oci {
                            message: format!("Cache error: {}", e),
                        },
                    })?;
                return Ok((feature, is_cached));
            }

            // Download and extract the layer
            let layer_data = self
                .download_layer(feature_ref, &layer.digest)
                .await
                .map_err(|e| match e {
                    crate::errors::DeaconError::Feature(f) => f,
                    _ => FeatureError::Oci {
                        message: format!("Download error: {}", e),
                    },
                })?;
            let extracted_dir = self
                .extract_layer(layer_data, &cache_key)
                .await
                .map_err(|e| match e {
                    crate::errors::DeaconError::Feature(f) => f,
                    _ => FeatureError::Oci {
                        message: format!("Extract error: {}", e),
                    },
                })?;

            // Parse metadata
            let metadata_path = extracted_dir.join("devcontainer-feature.json");
            let metadata = parse_feature_metadata(&metadata_path).map_err(|e| match e {
                crate::errors::DeaconError::Feature(f) => f,
                _ => FeatureError::Oci {
                    message: format!("Metadata parse error: {}", e),
                },
            })?;

            // Validate metadata before use
            metadata.validate()?;

            info!("Successfully fetched feature: {}", metadata.id);
            Ok((
                DownloadedFeature {
                    path: extracted_dir,
                    metadata,
                    digest: layer.digest.clone(),
                },
                is_cached,
            ))
        }
        .await;

        // Emit fetch end event
        let end_timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64;
        let duration_ms = start_time.elapsed().as_millis() as u64;

        self.emit_progress_event(ProgressEvent::OciFetchEnd {
            id: event_id,
            timestamp: end_timestamp,
            registry: feature_ref.registry.clone(),
            repository: feature_ref.repository(),
            tag: feature_ref.tag().to_string(),
            duration_ms,
            success: result.is_ok(),
            cached: result.as_ref().map(|(_, cached)| *cached).unwrap_or(false),
        })
        .await;

        result.map(|(feature, _)| feature).map_err(Into::into)
    }

    /// Install a downloaded feature by executing its install script
    #[instrument(level = "info", skip(self))]
    pub async fn install_feature(&self, feature: &DownloadedFeature) -> Result<()> {
        info!("Installing feature: {}", feature.metadata.id);

        let install_script = feature.path.join("install.sh");
        if !install_script.exists() {
            info!("No install.sh script found, skipping installation");
            return Ok(());
        }

        // Set up environment variables
        let mut env_vars = HashMap::new();
        env_vars.insert("FEATURE_ID".to_string(), feature.metadata.id.clone());
        if let Some(version) = &feature.metadata.version {
            env_vars.insert("FEATURE_VERSION".to_string(), version.clone());
        }

        // Execute the install script
        self.execute_install_script(&install_script, &env_vars)
            .await?;

        info!("Feature installation completed: {}", feature.metadata.id);
        Ok(())
    }

    /// Get the OCI manifest for a feature
    pub async fn get_manifest(&self, feature_ref: &FeatureRef) -> Result<Manifest> {
        let manifest_url = format!(
            "https://{}/v2/{}/manifests/{}",
            feature_ref.registry,
            feature_ref.repository(),
            feature_ref.tag()
        );

        debug!("Fetching manifest from: {}", manifest_url);

        let mut headers = HashMap::new();
        headers.insert(
            "Accept".to_string(),
            "application/vnd.oci.image.manifest.v1+json".to_string(),
        );

        // Retry the manifest download with exponential backoff
        let manifest_data = retry_async(
            &self.retry_config,
            || {
                let client = &self.client;
                let url = &manifest_url;
                let headers = headers.clone();
                async move {
                    client.get_with_headers(url, headers).await.map_err(|e| {
                        let error_msg = e.to_string();
                        if error_msg.contains("Authentication failed") {
                            FeatureError::Authentication {
                                message: format!("Failed to authenticate for manifest: {}", e),
                            }
                        } else {
                            FeatureError::Download {
                                message: format!("Failed to download manifest: {}", e),
                            }
                        }
                    })
                }
            },
            classify_network_error,
        )
        .await?;

        let manifest: Manifest =
            serde_json::from_slice(&manifest_data).map_err(|e| FeatureError::Parsing {
                message: format!("Failed to parse manifest: {}", e),
            })?;

        Ok(manifest)
    }

    /// Get the OCI manifest for a feature with SHA256 digest of the raw body
    ///
    /// Returns both the parsed manifest JSON and the SHA256 hex digest of the raw manifest body.
    /// This is useful for computing canonical IDs and verifying manifest integrity.
    pub async fn get_manifest_with_digest(
        &self,
        feature_ref: &FeatureRef,
    ) -> Result<(serde_json::Value, String)> {
        let manifest_url = format!(
            "https://{}/v2/{}/manifests/{}",
            feature_ref.registry,
            feature_ref.repository(),
            feature_ref.tag()
        );

        debug!("Fetching manifest with digest from: {}", manifest_url);

        let mut headers = HashMap::new();
        headers.insert(
            "Accept".to_string(),
            "application/vnd.oci.image.manifest.v1+json".to_string(),
        );

        // Retry the manifest download with exponential backoff
        let manifest_data = retry_async(
            &self.retry_config,
            || {
                let client = &self.client;
                let url = &manifest_url;
                let headers = headers.clone();
                async move {
                    client.get_with_headers(url, headers).await.map_err(|e| {
                        let error_msg = e.to_string();
                        if error_msg.contains("Authentication failed") {
                            FeatureError::Authentication {
                                message: format!("Failed to authenticate for manifest: {}", e),
                            }
                        } else {
                            FeatureError::Download {
                                message: format!("Failed to download manifest: {}", e),
                            }
                        }
                    })
                }
            },
            classify_network_error,
        )
        .await?;

        // Compute SHA256 digest of the raw manifest body
        let mut hasher = Sha256::new();
        hasher.update(&manifest_data);
        let digest = format!("{:x}", hasher.finalize());

        // Parse the manifest JSON
        let manifest: serde_json::Value =
            serde_json::from_slice(&manifest_data).map_err(|e| FeatureError::Parsing {
                message: format!("Failed to parse manifest: {}", e),
            })?;

        debug!("Manifest fetched with digest: {}", digest);
        Ok((manifest, digest))
    }

    /// Publish a feature to an OCI registry
    #[instrument(level = "info", skip(self, tar_data))]
    pub async fn publish_feature(
        &self,
        feature_ref: &FeatureRef,
        tar_data: Bytes,
        metadata: &FeatureMetadata,
    ) -> Result<PublishResult> {
        let start_time = Instant::now();
        let event_id =
            crate::progress::EVENT_ID_COUNTER.fetch_add(1, std::sync::atomic::Ordering::SeqCst);
        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64;

        // Emit publish begin event
        self.emit_progress_event(ProgressEvent::OciPublishBegin {
            id: event_id,
            timestamp,
            registry: feature_ref.registry.clone(),
            repository: feature_ref.repository(),
            tag: feature_ref.tag().to_string(),
        })
        .await;

        info!("Publishing feature: {}", feature_ref.reference());

        let result = async {
            // Calculate digest for the tar layer
            let mut hasher = Sha256::new();
            hasher.update(&tar_data);
            let layer_digest = format!("sha256:{:x}", hasher.finalize());
            let layer_size = tar_data.len() as u64;

            // Upload the blob (layer)
            self.upload_blob(feature_ref, &layer_digest, tar_data)
                .await
                .map_err(|e| match e {
                    crate::errors::DeaconError::Feature(f) => f,
                    _ => FeatureError::Oci { message: format!("Upload blob error: {}", e) },
                })?;

            // Create and upload manifest
            let manifest = serde_json::json!({
                "schemaVersion": 2,
                "mediaType": "application/vnd.oci.image.manifest.v1+json",
                "config": {
                    "mediaType": "application/vnd.devcontainers.feature.config.v1+json",
                    "size": 0,
                    "digest": "sha256:44136fa355b3678a1146ad16f7e8649e94fb4fc21fe77e8310c060f61caaff8a"
                },
                "layers": [{
                    "mediaType": "application/vnd.oci.image.layer.v1.tar",
                    "size": layer_size,
                    "digest": layer_digest
                }],
                "annotations": {
                    "org.opencontainers.image.title": metadata.name.as_deref().unwrap_or(&metadata.id),
                    "org.opencontainers.image.description": metadata.description.as_deref().unwrap_or(""),
                    "org.opencontainers.image.version": metadata.version.as_deref().unwrap_or("latest")
                }
            });

            let manifest_bytes =
                Bytes::from(serde_json::to_vec(&manifest).map_err(FeatureError::Json)?);
            let manifest_digest = self
                .upload_manifest(feature_ref, manifest_bytes.clone())
                .await
                .map_err(|e| match e {
                    crate::errors::DeaconError::Feature(f) => f,
                    _ => FeatureError::Oci { message: format!("Upload manifest error: {}", e) },
                })?;

            info!(
                "Successfully published feature {} with digest {}",
                feature_ref.reference(),
                manifest_digest
            );

            Ok::<_, crate::errors::FeatureError>(PublishResult {
                registry: feature_ref.registry.clone(),
                repository: feature_ref.repository(),
                tag: feature_ref.tag().to_string(),
                digest: manifest_digest.clone(),
                size: layer_size,
            })
        }.await;

        // Emit publish end event
        let end_timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64;
        let duration_ms = start_time.elapsed().as_millis() as u64;

        self.emit_progress_event(ProgressEvent::OciPublishEnd {
            id: event_id,
            timestamp: end_timestamp,
            registry: feature_ref.registry.clone(),
            repository: feature_ref.repository(),
            tag: feature_ref.tag().to_string(),
            duration_ms,
            success: result.is_ok(),
            digest: result.as_ref().ok().map(|r| r.digest.clone()),
        })
        .await;

        result.map_err(Into::into)
    }

    /// Publish a template to an OCI registry
    #[instrument(level = "info", skip(self, tar_data))]
    pub async fn publish_template(
        &self,
        template_ref: &TemplateRef,
        tar_data: Bytes,
        metadata: &crate::templates::TemplateMetadata,
    ) -> Result<PublishResult> {
        info!("Publishing template: {}", template_ref.reference());

        // Calculate digest for the tar layer
        let mut hasher = Sha256::new();
        hasher.update(&tar_data);
        let layer_digest = format!("sha256:{:x}", hasher.finalize());
        let layer_size = tar_data.len() as u64;

        // Upload the blob (layer)
        self.upload_blob_template(template_ref, &layer_digest, tar_data)
            .await?;

        // Create and upload manifest
        let manifest = serde_json::json!({
            "schemaVersion": 2,
            "mediaType": "application/vnd.oci.image.manifest.v1+json",
            "config": {
                "mediaType": "application/vnd.devcontainers.template.config.v1+json",
                "size": 0,
                "digest": "sha256:44136fa355b3678a1146ad16f7e8649e94fb4fc21fe77e8310c060f61caaff8a"
            },
            "layers": [{
                "mediaType": "application/vnd.oci.image.layer.v1.tar",
                "size": layer_size,
                "digest": layer_digest
            }],
            "annotations": {
                "org.opencontainers.image.title": metadata.name.as_deref().unwrap_or(&metadata.id),
                "org.opencontainers.image.description": metadata.description.as_deref().unwrap_or(""),
                "org.opencontainers.image.version": metadata.version.as_deref().unwrap_or("latest")
            }
        });

        let manifest_bytes =
            Bytes::from(serde_json::to_vec(&manifest).map_err(FeatureError::Json)?);
        let manifest_digest = self
            .upload_manifest_template(template_ref, manifest_bytes.clone())
            .await?;

        info!(
            "Successfully published template {} with digest {}",
            template_ref.reference(),
            manifest_digest
        );

        Ok(PublishResult {
            registry: template_ref.registry.clone(),
            repository: template_ref.repository(),
            tag: template_ref.tag().to_string(),
            digest: manifest_digest,
            size: layer_size,
        })
    }

    /// Fetch a template from an OCI registry  
    #[instrument(level = "info", skip(self))]
    pub async fn fetch_template(&self, template_ref: &TemplateRef) -> Result<DownloadedTemplate> {
        info!("Fetching template: {}", template_ref.reference());

        // Get the manifest
        let manifest = self.get_manifest_template(template_ref).await?;
        debug!("Got manifest with {} layers", manifest.layers.len());

        // For now, assume single tar layer (as per requirements)
        if manifest.layers.is_empty() {
            return Err(FeatureError::Oci {
                message: "No layers found in manifest".to_string(),
            }
            .into());
        }

        let layer = &manifest.layers[0];
        debug!("Using layer: digest={}, size={}", layer.digest, layer.size);

        // Check cache first
        let cache_key = self.get_cache_key(&layer.digest);
        let cached_dir = self.cache_dir.join(&cache_key);

        if cached_dir.exists() {
            info!("Found cached template at: {}", cached_dir.display());
            return self
                .load_cached_template(cached_dir, layer.digest.clone())
                .await;
        }

        // Download and extract the layer
        let layer_data = self
            .download_layer_template(template_ref, &layer.digest)
            .await?;
        let extracted_dir = self.extract_layer(layer_data, &cache_key).await?;

        // Parse metadata
        let metadata_path = extracted_dir.join("devcontainer-template.json");
        let metadata = crate::templates::parse_template_metadata(&metadata_path)?;

        info!("Successfully fetched template: {}", metadata.id);
        Ok(DownloadedTemplate {
            path: extracted_dir,
            metadata,
            digest: layer.digest.clone(),
        })
    }

    /// Upload a blob to any registry with a generic reference
    /// Follows OCI Distribution Spec v2: POST to initiate, PUT to complete
    async fn upload_blob_generic(
        &self,
        registry: &str,
        repository: &str,
        digest: &str,
        data: Bytes,
    ) -> Result<()> {
        debug!(
            "Uploading blob to registry: {}, repository: {}, digest: {}, size: {} bytes",
            registry,
            repository,
            digest,
            data.len()
        );

        // Step 1: Check if blob already exists using HEAD request
        let blob_check_url = format!("https://{}/v2/{}/blobs/{}", registry, repository, digest);

        match self.client.head(&blob_check_url, HashMap::new()).await {
            Ok(status) => {
                if status == 200 {
                    debug!(
                        "Blob already exists in registry (status {}), skipping upload",
                        status
                    );
                    return Ok(());
                } else if status == 404 {
                    debug!("Blob not found in registry (status 404), proceeding with upload");
                } else if status == 401 || status == 403 {
                    return Err(FeatureError::Authentication {
                        message: format!(
                            "Authentication failed when checking blob existence (status {})",
                            status
                        ),
                    }
                    .into());
                } else if status >= 500 {
                    return Err(FeatureError::Oci {
                        message: format!(
                            "Registry server error when checking blob existence (status {})",
                            status
                        ),
                    }
                    .into());
                } else {
                    debug!(
                        "Unexpected status {} when checking blob existence, proceeding with upload",
                        status
                    );
                }
            }
            Err(e) => {
                // If HEAD request fails, log and proceed with upload anyway
                debug!("HEAD request failed: {}, proceeding with upload", e);
            }
        }

        // Step 2: Initiate upload session (POST to /v2/{repo}/blobs/uploads/)
        let upload_url = format!("https://{}/v2/{}/blobs/uploads/", registry, repository);
        debug!("Initiating upload session at: {}", upload_url);

        let empty_body = Bytes::new();
        let response = self
            .client
            .post_with_headers(&upload_url, empty_body, HashMap::new())
            .await
            .map_err(|e| FeatureError::Oci {
                message: format!("Failed to initiate blob upload: {}", e),
            })?;

        // Extract Location header from POST response per OCI spec
        let location = response
            .headers
            .get("location")
            .or_else(|| response.headers.get("Location"))
            .ok_or_else(|| FeatureError::Oci {
                message: "Missing Location header in upload initiation response".to_string(),
            })?
            .clone();

        debug!("Upload session initiated, location: {}", location);

        // Build final upload URL by appending digest query parameter to Location
        let upload_location = if location.contains('?') {
            format!("{}&digest={}", location, digest)
        } else {
            format!("{}?digest={}", location, digest)
        };

        debug!("Uploading blob to: {}", upload_location);

        // Step 3: Upload blob with monolithic PUT (entire blob in one request)
        let mut headers = HashMap::new();
        headers.insert(
            "Content-Type".to_string(),
            "application/octet-stream".to_string(),
        );
        headers.insert("Content-Length".to_string(), data.len().to_string());

        // Retry blob upload with exponential backoff
        retry_async(
            &self.retry_config,
            || {
                let client = &self.client;
                let url = &upload_location;
                let data_clone = data.clone();
                let headers_clone = headers.clone();
                async move {
                    client
                        .put_with_headers(url, data_clone, headers_clone)
                        .await
                        .map_err(|e| {
                            let error_msg = e.to_string();
                            if error_msg.contains("Authentication failed") {
                                FeatureError::Authentication {
                                    message: format!(
                                        "Failed to authenticate for blob upload: {}",
                                        e
                                    ),
                                }
                            } else {
                                FeatureError::Oci {
                                    message: format!("Failed to upload blob: {}", e),
                                }
                            }
                        })
                }
            },
            classify_network_error,
        )
        .await?;

        debug!("Blob uploaded successfully: {}", digest);
        Ok(())
    }

    /// Upload a blob to the registry for features
    async fn upload_blob(&self, feature_ref: &FeatureRef, digest: &str, data: Bytes) -> Result<()> {
        self.upload_blob_generic(
            &feature_ref.registry,
            &feature_ref.repository(),
            digest,
            data,
        )
        .await
    }

    /// Upload a blob to the registry for templates
    async fn upload_blob_template(
        &self,
        template_ref: &TemplateRef,
        digest: &str,
        data: Bytes,
    ) -> Result<()> {
        self.upload_blob_generic(
            &template_ref.registry,
            &template_ref.repository(),
            digest,
            data,
        )
        .await
    }

    /// Upload a manifest to the registry for features
    async fn upload_manifest(
        &self,
        feature_ref: &FeatureRef,
        manifest_data: Bytes,
    ) -> Result<String> {
        let manifest_url = format!(
            "https://{}/v2/{}/manifests/{}",
            feature_ref.registry,
            feature_ref.repository(),
            feature_ref.tag()
        );

        debug!("Uploading manifest to: {}", manifest_url);

        let mut headers = HashMap::new();
        headers.insert(
            "Content-Type".to_string(),
            "application/vnd.oci.image.manifest.v1+json".to_string(),
        );

        // Retry manifest upload with exponential backoff
        retry_async(
            &self.retry_config,
            || {
                let client = &self.client;
                let url = &manifest_url;
                let data = manifest_data.clone();
                let headers = headers.clone();
                async move {
                    client
                        .put_with_headers(url, data, headers)
                        .await
                        .map_err(|e| {
                            let error_msg = e.to_string();
                            if error_msg.contains("Authentication failed") {
                                FeatureError::Authentication {
                                    message: format!(
                                        "Failed to authenticate for manifest upload: {}",
                                        e
                                    ),
                                }
                            } else {
                                FeatureError::Oci {
                                    message: format!("Failed to upload manifest: {}", e),
                                }
                            }
                        })
                }
            },
            classify_network_error,
        )
        .await?;

        // Calculate digest of the manifest
        let mut hasher = Sha256::new();
        hasher.update(&manifest_data);
        let digest = format!("sha256:{:x}", hasher.finalize());

        debug!("Manifest uploaded with digest: {}", digest);
        Ok(digest)
    }

    /// Upload a manifest to the registry for templates
    async fn upload_manifest_template(
        &self,
        template_ref: &TemplateRef,
        manifest_data: Bytes,
    ) -> Result<String> {
        let manifest_url = format!(
            "https://{}/v2/{}/manifests/{}",
            template_ref.registry,
            template_ref.repository(),
            template_ref.tag()
        );

        debug!("Uploading manifest to: {}", manifest_url);

        let mut headers = HashMap::new();
        headers.insert(
            "Content-Type".to_string(),
            "application/vnd.oci.image.manifest.v1+json".to_string(),
        );

        // Retry manifest upload with exponential backoff
        retry_async(
            &self.retry_config,
            || {
                let client = &self.client;
                let url = &manifest_url;
                let data = manifest_data.clone();
                let headers = headers.clone();
                async move {
                    client
                        .put_with_headers(url, data, headers)
                        .await
                        .map_err(|e| {
                            let error_msg = e.to_string();
                            if error_msg.contains("Authentication failed") {
                                FeatureError::Authentication {
                                    message: format!(
                                        "Failed to authenticate for manifest upload: {}",
                                        e
                                    ),
                                }
                            } else {
                                FeatureError::Oci {
                                    message: format!("Failed to upload manifest: {}", e),
                                }
                            }
                        })
                }
            },
            classify_network_error,
        )
        .await?;

        // Calculate digest of the manifest
        let mut hasher = Sha256::new();
        hasher.update(&manifest_data);
        let digest = format!("sha256:{:x}", hasher.finalize());

        debug!("Manifest uploaded with digest: {}", digest);
        Ok(digest)
    }

    /// Get the OCI manifest for a template
    async fn get_manifest_template(&self, template_ref: &TemplateRef) -> Result<Manifest> {
        let manifest_url = format!(
            "https://{}/v2/{}/manifests/{}",
            template_ref.registry,
            template_ref.repository(),
            template_ref.tag()
        );

        debug!("Fetching manifest from: {}", manifest_url);

        let mut headers = HashMap::new();
        headers.insert(
            "Accept".to_string(),
            "application/vnd.oci.image.manifest.v1+json".to_string(),
        );

        // Retry the manifest download with exponential backoff
        let manifest_data = retry_async(
            &self.retry_config,
            || {
                let client = &self.client;
                let url = &manifest_url;
                let headers = headers.clone();
                async move {
                    client.get_with_headers(url, headers).await.map_err(|e| {
                        let error_msg = e.to_string();
                        if error_msg.contains("Authentication failed") {
                            FeatureError::Authentication {
                                message: format!("Failed to authenticate for manifest: {}", e),
                            }
                        } else {
                            FeatureError::Download {
                                message: format!("Failed to download manifest: {}", e),
                            }
                        }
                    })
                }
            },
            classify_network_error,
        )
        .await?;

        let manifest: Manifest =
            serde_json::from_slice(&manifest_data).map_err(|e| FeatureError::Parsing {
                message: format!("Failed to parse manifest: {}", e),
            })?;

        Ok(manifest)
    }

    /// Download a layer blob for templates
    async fn download_layer_template(
        &self,
        template_ref: &TemplateRef,
        digest: &str,
    ) -> Result<Bytes> {
        let blob_url = format!(
            "https://{}/v2/{}/blobs/{}",
            template_ref.registry,
            template_ref.repository(),
            digest
        );

        debug!("Downloading layer from: {}", blob_url);

        // Retry the layer download with exponential backoff
        let layer_data = retry_async(
            &self.retry_config,
            || {
                let client = &self.client;
                let url = &blob_url;
                async move {
                    client.get(url).await.map_err(|e| {
                        let error_msg = e.to_string();
                        if error_msg.contains("Authentication failed") {
                            FeatureError::Authentication {
                                message: format!("Failed to authenticate for layer: {}", e),
                            }
                        } else {
                            FeatureError::Download {
                                message: format!("Failed to download layer: {}", e),
                            }
                        }
                    })
                }
            },
            classify_network_error,
        )
        .await?;

        Ok(layer_data)
    }

    /// Load cached template from directory
    async fn load_cached_template(
        &self,
        cached_dir: PathBuf,
        digest: String,
    ) -> Result<DownloadedTemplate> {
        let metadata_path = cached_dir.join("devcontainer-template.json");
        let metadata = crate::templates::parse_template_metadata(&metadata_path)?;

        Ok(DownloadedTemplate {
            path: cached_dir,
            metadata,
            digest,
        })
    }

    /// Download a layer blob
    async fn download_layer(&self, feature_ref: &FeatureRef, digest: &str) -> Result<Bytes> {
        let blob_url = format!(
            "https://{}/v2/{}/blobs/{}",
            feature_ref.registry,
            feature_ref.repository(),
            digest
        );

        debug!("Downloading layer from: {}", blob_url);

        // Retry the layer download with exponential backoff
        let layer_data = retry_async(
            &self.retry_config,
            || {
                let client = &self.client;
                let url = &blob_url;
                async move {
                    client.get(url).await.map_err(|e| {
                        let error_msg = e.to_string();
                        if error_msg.contains("Authentication failed") {
                            FeatureError::Authentication {
                                message: format!("Failed to authenticate for layer: {}", e),
                            }
                        } else {
                            FeatureError::Download {
                                message: format!("Failed to download layer: {}", e),
                            }
                        }
                    })
                }
            },
            classify_network_error,
        )
        .await?;

        Ok(layer_data)
    }

    /// Extract a tar layer to the cache directory
    async fn extract_layer(&self, layer_data: Bytes, cache_key: &str) -> Result<PathBuf> {
        let extraction_dir = self.cache_dir.join(cache_key);

        // Create cache directory if it doesn't exist
        std::fs::create_dir_all(&extraction_dir).map_err(|e| FeatureError::Extraction {
            message: format!("Failed to create extraction directory: {}", e),
        })?;

        debug!("Extracting layer to: {}", extraction_dir.display());

        // Extract tar archive
        let cursor = std::io::Cursor::new(layer_data);
        let mut archive = Archive::new(cursor);

        archive
            .unpack(&extraction_dir)
            .map_err(|e| FeatureError::Extraction {
                message: format!("Failed to extract tar archive: {}", e),
            })?;

        Ok(extraction_dir)
    }

    /// Load a cached feature
    async fn load_cached_feature(
        &self,
        cached_dir: PathBuf,
        digest: String,
    ) -> Result<DownloadedFeature> {
        let metadata_path = cached_dir.join("devcontainer-feature.json");
        let metadata = parse_feature_metadata(&metadata_path)?;

        // Validate metadata before use
        metadata.validate()?;

        Ok(DownloadedFeature {
            path: cached_dir,
            metadata,
            digest,
        })
    }

    /// Parse the Link header to extract the next URL for pagination
    /// Link headers typically look like: `<url>; rel="next"`
    fn parse_next_link_from_headers(headers: &HashMap<String, String>) -> Option<String> {
        let link_header = headers.get("Link").or_else(|| headers.get("link"))?;

        // Parse Link header format: <url>; rel="next", <url>; rel="last"
        for link_part in link_header.split(',') {
            let link_part = link_part.trim();

            // Check if this part contains rel="next"
            if link_part.contains("rel=\"next\"") {
                // Extract the URL from <url>
                if let Some(start) = link_part.find('<') {
                    if let Some(end) = link_part.find('>') {
                        if start < end {
                            let url = &link_part[start + 1..end];
                            return Some(url.to_string());
                        }
                    }
                }
            }
        }

        None
    }

    /// Generate a cache key from a digest
    fn get_cache_key(&self, digest: &str) -> String {
        // Use a shortened version of the digest as cache key
        let mut hasher = Sha256::new();
        hasher.update(digest.as_bytes());
        let hash = hasher.finalize();
        format!("{:x}", hash)[..16].to_string()
    }

    /// Execute the install script with environment variables
    async fn execute_install_script(
        &self,
        script_path: &Path,
        env_vars: &HashMap<String, String>,
    ) -> Result<()> {
        use tokio::io::{AsyncBufReadExt, BufReader};
        use tokio::process::Command;

        debug!("Executing install script: {}", script_path.display());

        let mut command = Command::new("bash");
        command.arg(script_path);

        // Set environment variables
        for (key, value) in env_vars {
            command.env(key, value);
            debug!("Set environment variable: {}={}", key, value);
        }

        // Capture stdout and stderr for streaming
        command.stdout(std::process::Stdio::piped());
        command.stderr(std::process::Stdio::piped());

        // Spawn the child process
        let mut child = command.spawn().map_err(|e| FeatureError::Installation {
            message: format!("Failed to execute install script: {}", e),
        })?;

        // Get stdout and stderr handles
        let stdout = child
            .stdout
            .take()
            .ok_or_else(|| FeatureError::Installation {
                message: "Failed to capture stdout".to_string(),
            })?;
        let stderr = child
            .stderr
            .take()
            .ok_or_else(|| FeatureError::Installation {
                message: "Failed to capture stderr".to_string(),
            })?;

        // Stream stdout asynchronously
        let stdout_handle = tokio::spawn(async move {
            let reader = BufReader::new(stdout);
            let mut lines = reader.lines();
            while let Ok(Some(line)) = lines.next_line().await {
                info!("[install] stdout: {}", line);
            }
        });

        // Stream stderr asynchronously
        let stderr_handle = tokio::spawn(async move {
            let reader = BufReader::new(stderr);
            let mut lines = reader.lines();
            while let Ok(Some(line)) = lines.next_line().await {
                warn!("[install] stderr: {}", line);
            }
        });

        // Wait for the process to complete
        let status = child.wait().await.map_err(|e| FeatureError::Installation {
            message: format!("Failed to wait for install script: {}", e),
        })?;

        // Wait for output streaming tasks to complete
        let _ = tokio::try_join!(stdout_handle, stderr_handle);

        // Check exit status
        if !status.success() {
            return Err(FeatureError::Installation {
                message: format!(
                    "Install script failed with exit code: {}",
                    status.code().unwrap_or(-1)
                ),
            }
            .into());
        }

        debug!("Install script completed successfully");
        Ok(())
    }

    /// List tags for a repository with Link header pagination
    /// Implements OCI Distribution Spec `/v2/<name>/tags/list` endpoint
    /// Enforces: max 10 pages, max 1000 tags total
    #[instrument(level = "info", skip(self))]
    pub async fn list_tags(&self, feature_ref: &FeatureRef) -> Result<Vec<String>> {
        const MAX_PAGES: usize = 10;
        const MAX_TAGS: usize = 1000;

        let initial_url = format!(
            "https://{}/v2/{}/tags/list",
            feature_ref.registry,
            feature_ref.repository()
        );

        debug!("Fetching tags from: {}", initial_url);

        let mut headers = HashMap::new();
        headers.insert("Accept".to_string(), "application/json".to_string());

        let mut all_tags: Vec<String> = Vec::new();
        let mut page_count = 0;
        let mut current_url = initial_url.clone();

        loop {
            // Check if we've reached page limit
            if page_count >= MAX_PAGES {
                debug!("Reached maximum page limit ({} pages)", MAX_PAGES);
                break;
            }

            // Fetch current page
            let response = retry_async(
                &self.retry_config,
                || {
                    let client = &self.client;
                    let url = &current_url;
                    let headers = headers.clone();
                    async move {
                        client
                            .get_with_headers_and_response(url, headers)
                            .await
                            .map_err(|e| {
                                let error_msg = e.to_string();
                                if error_msg.contains("Authentication failed") {
                                    FeatureError::Authentication {
                                        message: format!(
                                            "Failed to authenticate for tags list: {}",
                                            e
                                        ),
                                    }
                                } else {
                                    FeatureError::Download {
                                        message: format!("Failed to download tags list: {}", e),
                                    }
                                }
                            })
                    }
                },
                classify_network_error,
            )
            .await?;

            // Parse tags from response
            let tag_list: TagList =
                serde_json::from_slice(&response.body).map_err(|e| FeatureError::Parsing {
                    message: format!("Failed to parse tags list: {}", e),
                })?;

            // Add tags to collection, but check for limit
            for tag in tag_list.tags {
                if all_tags.len() >= MAX_TAGS {
                    debug!("Reached maximum tag limit ({})", MAX_TAGS);
                    break;
                }
                all_tags.push(tag);
            }

            page_count += 1;

            // Check for Link header to get next page URL
            match Self::parse_next_link_from_headers(&response.headers) {
                Some(next_url) => {
                    debug!(
                        "Found next page link (page {}), fetching: {}",
                        page_count, next_url
                    );
                    current_url = next_url;
                }
                None => {
                    debug!(
                        "No more pages available (pagination ended at page {})",
                        page_count
                    );
                    break;
                }
            }

            // Stop if we've already hit the tag limit
            if all_tags.len() >= MAX_TAGS {
                break;
            }
        }

        // Remove duplicates while preserving insertion order
        let mut seen = std::collections::HashSet::new();
        all_tags.retain(|tag| seen.insert(tag.clone()));

        debug!(
            "Successfully fetched {} tags across {} pages",
            all_tags.len(),
            page_count
        );

        Ok(all_tags)
    }

    /// Get the OCI manifest for a feature by digest
    /// Allows fetching specific manifest versions using their digest
    #[instrument(level = "info", skip(self))]
    pub async fn get_manifest_by_digest(
        &self,
        feature_ref: &FeatureRef,
        digest: &str,
    ) -> Result<Manifest> {
        let manifest_url = format!(
            "https://{}/v2/{}/manifests/{}",
            feature_ref.registry,
            feature_ref.repository(),
            digest
        );

        debug!("Fetching manifest by digest from: {}", manifest_url);

        let mut headers = HashMap::new();
        headers.insert(
            "Accept".to_string(),
            "application/vnd.oci.image.manifest.v1+json".to_string(),
        );

        // Retry the manifest download with exponential backoff
        let manifest_data = retry_async(
            &self.retry_config,
            || {
                let client = &self.client;
                let url = &manifest_url;
                let headers = headers.clone();
                async move {
                    client.get_with_headers(url, headers).await.map_err(|e| {
                        let error_msg = e.to_string();
                        if error_msg.contains("Authentication failed") {
                            FeatureError::Authentication {
                                message: format!("Failed to authenticate for manifest: {}", e),
                            }
                        } else {
                            FeatureError::Download {
                                message: format!("Failed to download manifest: {}", e),
                            }
                        }
                    })
                }
            },
            classify_network_error,
        )
        .await?;

        let manifest: Manifest =
            serde_json::from_slice(&manifest_data).map_err(|e| FeatureError::Parsing {
                message: format!("Failed to parse manifest: {}", e),
            })?;

        Ok(manifest)
    }

    /// Publish a feature with multiple tags
    /// This is more efficient than calling publish_feature multiple times
    ///
    /// # Error Handling
    ///
    /// - If a tag already exists (manifest found), it is skipped with a log message
    /// - If manifest check returns 404 (not found), the tag is published
    /// - If manifest check returns other errors (network, auth, 5xx), the error is propagated
    #[instrument(level = "info", skip(self, tar_data))]
    pub async fn publish_feature_multi_tag(
        &self,
        registry: String,
        namespace: String,
        name: String,
        tags: Vec<String>,
        tar_data: Bytes,
        metadata: &FeatureMetadata,
    ) -> Result<Vec<PublishResult>> {
        info!(
            "Publishing feature {}/{} with {} tags",
            namespace,
            name,
            tags.len()
        );

        let mut results = Vec::new();

        for tag in tags {
            let feature_ref = FeatureRef::new(
                registry.clone(),
                namespace.clone(),
                name.clone(),
                Some(tag.clone()),
            );

            // Check if tag already exists by trying to fetch manifest
            match self.get_manifest(&feature_ref).await {
                Ok(_) => {
                    info!("Tag {} already exists, skipping", tag);
                    continue;
                }
                Err(e) => {
                    // Inspect the error to determine if it's a 404 (tag doesn't exist)
                    // or a different error (network, auth, etc.)
                    let error_msg = e.to_string().to_lowercase();

                    // Check if this is a "not found" error (404)
                    // Common patterns: "404", "not found", "no such"
                    let is_not_found = error_msg.contains("404")
                        || error_msg.contains("not found")
                        || error_msg.contains("no such");

                    if is_not_found {
                        // Tag doesn't exist, proceed with publishing
                        debug!("Tag {} doesn't exist, publishing", tag);
                    } else {
                        // This is a different error (network, auth, 5xx, etc.)
                        // Propagate it instead of continuing
                        warn!("Failed to check if tag {} exists: {}", tag, e);
                        return Err(e);
                    }
                }
            }

            let result = self
                .publish_feature(&feature_ref, tar_data.clone(), metadata)
                .await?;
            results.push(result);
        }

        info!(
            "Successfully published {} tags for {}/{}",
            results.len(),
            namespace,
            name
        );
        Ok(results)
    }

    /// Publish collection metadata as an OCI artifact
    ///
    /// This publishes the devcontainer-collection.json as an OCI artifact to the
    /// collection repository `<registry>/<namespace>` with tag `collection`.
    /// The collection JSON is stored as the config blob with media type
    /// `application/vnd.devcontainer.collection+json`.
    ///
    /// # Arguments
    /// * `registry` - The registry hostname (e.g., "ghcr.io")
    /// * `namespace` - The namespace/repository path (e.g., "owner/repo")
    /// * `collection_json` - The collection metadata as JSON bytes
    ///
    /// # Returns
    /// The digest of the published manifest
    #[instrument(level = "info", skip(self, collection_json))]
    pub async fn publish_collection_metadata(
        &self,
        registry: &str,
        namespace: &str,
        collection_json: Bytes,
    ) -> Result<String> {
        info!(
            "Publishing collection metadata to {}/{}",
            registry, namespace
        );

        // Calculate digest for the collection JSON
        let mut hasher = Sha256::new();
        hasher.update(&collection_json);
        let config_digest = format!("sha256:{:x}", hasher.finalize());
        let config_size = collection_json.len() as u64;

        // Upload the collection JSON as a blob
        self.upload_blob_generic(registry, namespace, &config_digest, collection_json)
            .await
            .map_err(|e| match e {
                crate::errors::DeaconError::Feature(f) => f,
                _ => FeatureError::Oci {
                    message: format!("Upload collection blob error: {}", e),
                },
            })?;

        // Create manifest for the collection artifact
        let manifest = serde_json::json!({
            "schemaVersion": 2,
            "mediaType": "application/vnd.oci.image.manifest.v1+json",
            "config": {
                "mediaType": "application/vnd.devcontainer.collection+json",
                "size": config_size,
                "digest": config_digest
            },
            "layers": [],
            "annotations": {
                "org.opencontainers.image.title": "DevContainer Collection",
                "org.opencontainers.image.description": "DevContainer feature and template collection metadata"
            }
        });

        let manifest_bytes =
            Bytes::from(serde_json::to_vec(&manifest).map_err(FeatureError::Json)?);

        // Upload manifest to the collection tag
        let manifest_url = format!("https://{}/v2/{}/manifests/collection", registry, namespace);

        debug!("Uploading collection manifest to: {}", manifest_url);

        let mut headers = HashMap::new();
        headers.insert(
            "Content-Type".to_string(),
            "application/vnd.oci.image.manifest.v1+json".to_string(),
        );

        // Retry manifest upload with exponential backoff
        retry_async(
            &self.retry_config,
            || {
                let client = &self.client;
                let url = &manifest_url;
                let data = manifest_bytes.clone();
                let headers = headers.clone();
                async move {
                    client
                        .put_with_headers(url, data, headers)
                        .await
                        .map_err(|e| {
                            let error_msg = e.to_string();
                            if error_msg.contains("Authentication failed") {
                                FeatureError::Authentication {
                                    message: format!(
                                        "Failed to authenticate for collection manifest upload: {}",
                                        e
                                    ),
                                }
                            } else {
                                FeatureError::Oci {
                                    message: format!("Failed to upload collection manifest: {}", e),
                                }
                            }
                        })
                }
            },
            classify_network_error,
        )
        .await?;

        // Calculate digest of the manifest
        let mut hasher = Sha256::new();
        hasher.update(&manifest_bytes);
        let manifest_digest = format!("sha256:{:x}", hasher.finalize());

        info!(
            "Successfully published collection metadata with digest {}",
            manifest_digest
        );
        Ok(manifest_digest)
    }
}

// Re-export semver_utils for backwards compatibility with oci::semver_utils path
pub use crate::semver_utils;

/// Convenience function to create a default feature fetcher
pub fn default_fetcher() -> Result<FeatureFetcher<ReqwestClient>> {
    let client = ReqwestClient::new().map_err(|e| FeatureError::Authentication {
        message: format!("Failed to create HTTP client: {}", e),
    })?;
    Ok(FeatureFetcher::new(client))
}

/// Create a feature fetcher with custom timeout and retry configuration
///
/// This function is useful for operations that need predictable performance guarantees,
/// such as the read-configuration command which should minimize latency.
///
/// # Arguments
/// * `timeout` - Timeout for each HTTP request (e.g., 2 seconds)
/// * `retry_config` - Retry configuration (max attempts, backoff delays)
///
/// # Examples
/// ```
/// use deacon_core::oci::default_fetcher_with_config;
/// use deacon_core::retry::RetryConfig;
/// use std::time::Duration;
///
/// // Create fetcher with 2s timeout and 1 retry
/// let retry_config = RetryConfig::new(
///     1, // max_attempts (1 retry after initial attempt)
///     Duration::from_millis(100), // base_delay
///     Duration::from_secs(1), // max_delay
///     deacon_core::retry::JitterStrategy::FullJitter,
/// );
/// let fetcher = default_fetcher_with_config(
///     Some(Duration::from_secs(2)),
///     retry_config,
/// );
/// ```
pub fn default_fetcher_with_config(
    timeout: Option<Duration>,
    retry_config: RetryConfig,
) -> Result<FeatureFetcher<ReqwestClient>> {
    let client =
        ReqwestClient::with_timeout(timeout).map_err(|e| FeatureError::Authentication {
            message: format!("Failed to create HTTP client with timeout: {}", e),
        })?;

    let cache_dir = get_features_cache_dir()?;
    Ok(FeatureFetcher::with_retry_config(
        client,
        cache_dir,
        retry_config,
    ))
}

/// Mock HTTP client for testing
#[derive(Debug, Clone)]
pub struct MockHttpClient {
    responses: Arc<Mutex<HashMap<String, Bytes>>>,
    response_with_headers: Arc<Mutex<HashMap<String, HttpResponse>>>,
    head_responses: Arc<Mutex<HashMap<String, u16>>>,
}

impl MockHttpClient {
    pub fn new() -> Self {
        Self {
            responses: Arc::new(Mutex::new(HashMap::new())),
            response_with_headers: Arc::new(Mutex::new(HashMap::new())),
            head_responses: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    pub async fn add_response(&self, url: String, response: Bytes) {
        let mut responses = self.responses.lock().await;
        responses.insert(url, response);
    }

    pub async fn add_response_with_headers(&self, url: String, response: HttpResponse) {
        let mut responses = self.response_with_headers.lock().await;
        responses.insert(url, response);
    }

    pub async fn add_head_response(&self, url: String, status: u16) {
        let mut responses = self.head_responses.lock().await;
        responses.insert(url, status);
    }
}

impl Default for MockHttpClient {
    fn default() -> Self {
        Self::new()
    }
}

#[async_trait::async_trait]
impl HttpClient for MockHttpClient {
    async fn get(
        &self,
        url: &str,
    ) -> std::result::Result<Bytes, Box<dyn std::error::Error + Send + Sync>> {
        let responses = self.responses.lock().await;
        responses
            .get(url)
            .cloned()
            .ok_or_else(|| format!("No mock response for URL: {}", url).into())
    }

    async fn get_with_headers(
        &self,
        url: &str,
        _headers: HashMap<String, String>,
    ) -> std::result::Result<Bytes, Box<dyn std::error::Error + Send + Sync>> {
        self.get(url).await
    }

    async fn get_with_headers_and_response(
        &self,
        url: &str,
        _headers: HashMap<String, String>,
    ) -> std::result::Result<HttpResponse, Box<dyn std::error::Error + Send + Sync>> {
        // Check for response with headers first
        let response_with_headers = self.response_with_headers.lock().await;
        if let Some(response) = response_with_headers.get(url) {
            return Ok(response.clone());
        }
        drop(response_with_headers);

        // Fall back to simple response
        let responses = self.responses.lock().await;
        responses
            .get(url)
            .cloned()
            .map(|body| HttpResponse {
                status: 200,
                headers: HashMap::new(),
                body,
            })
            .ok_or_else(|| format!("No mock response for URL: {}", url).into())
    }

    async fn head(
        &self,
        url: &str,
        _headers: HashMap<String, String>,
    ) -> std::result::Result<u16, Box<dyn std::error::Error + Send + Sync>> {
        let responses = self.head_responses.lock().await;
        responses
            .get(url)
            .copied()
            .ok_or_else(|| format!("No mock HEAD response for URL: {}", url).into())
    }

    async fn put_with_headers(
        &self,
        url: &str,
        _data: Bytes,
        _headers: HashMap<String, String>,
    ) -> std::result::Result<Bytes, Box<dyn std::error::Error + Send + Sync>> {
        let responses = self.responses.lock().await;
        responses
            .get(url)
            .cloned()
            .ok_or_else(|| format!("No mock response for URL: {}", url).into())
    }

    async fn post_with_headers(
        &self,
        url: &str,
        _data: Bytes,
        _headers: HashMap<String, String>,
    ) -> std::result::Result<HttpResponse, Box<dyn std::error::Error + Send + Sync>> {
        // Check for response with headers first
        let response_with_headers = self.response_with_headers.lock().await;
        if let Some(response) = response_with_headers.get(url) {
            return Ok(response.clone());
        }
        drop(response_with_headers);

        // Fall back to simple response
        let responses = self.responses.lock().await;
        responses
            .get(url)
            .cloned()
            .map(|body| HttpResponse {
                status: 200,
                headers: HashMap::new(),
                body,
            })
            .ok_or_else(|| format!("No mock response for URL: {}", url).into())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_feature_ref_creation() {
        let feature_ref = FeatureRef::new(
            "ghcr.io".to_string(),
            "devcontainers".to_string(),
            "node".to_string(),
            Some("18".to_string()),
        );

        assert_eq!(feature_ref.registry, "ghcr.io");
        assert_eq!(feature_ref.namespace, "devcontainers");
        assert_eq!(feature_ref.name, "node");
        assert_eq!(feature_ref.version, Some("18".to_string()));
        assert_eq!(feature_ref.tag(), "18");
        assert_eq!(feature_ref.repository(), "devcontainers/node");
        assert_eq!(feature_ref.reference(), "ghcr.io/devcontainers/node:18");
    }

    #[test]
    fn test_feature_ref_default_version() {
        let feature_ref = FeatureRef::new(
            "ghcr.io".to_string(),
            "devcontainers".to_string(),
            "node".to_string(),
            None,
        );

        assert_eq!(feature_ref.tag(), "latest");
        assert_eq!(feature_ref.reference(), "ghcr.io/devcontainers/node:latest");
    }

    #[test]
    fn test_template_ref_creation() {
        let template_ref = TemplateRef::new(
            "ghcr.io".to_string(),
            "devcontainers".to_string(),
            "python".to_string(),
            Some("3.11".to_string()),
        );

        assert_eq!(template_ref.registry, "ghcr.io");
        assert_eq!(template_ref.namespace, "devcontainers");
        assert_eq!(template_ref.name, "python");
        assert_eq!(template_ref.version, Some("3.11".to_string()));
        assert_eq!(template_ref.tag(), "3.11");
        assert_eq!(template_ref.repository(), "devcontainers/python");
        assert_eq!(
            template_ref.reference(),
            "ghcr.io/devcontainers/python:3.11"
        );
    }

    #[test]
    fn test_template_ref_default_version() {
        let template_ref = TemplateRef::new(
            "ghcr.io".to_string(),
            "devcontainers".to_string(),
            "python".to_string(),
            None,
        );

        assert_eq!(template_ref.tag(), "latest");
        assert_eq!(
            template_ref.reference(),
            "ghcr.io/devcontainers/python:latest"
        );
    }

    #[test]
    fn test_registry_credentials_auth_header() {
        // Test Basic authentication
        let basic_creds = RegistryCredentials::Basic {
            username: "user".to_string(),
            password: "pass".to_string(),
        };
        let auth_header = basic_creds.to_auth_header().unwrap();
        assert!(auth_header.starts_with("Basic "));

        // Decode and verify
        let encoded = auth_header.strip_prefix("Basic ").unwrap();
        let decoded = base64::engine::general_purpose::STANDARD
            .decode(encoded)
            .unwrap();
        let decoded_str = String::from_utf8(decoded).unwrap();
        assert_eq!(decoded_str, "user:pass");

        // Test Bearer authentication
        let bearer_creds = RegistryCredentials::Bearer {
            token: "abc123".to_string(),
        };
        let auth_header = bearer_creds.to_auth_header().unwrap();
        assert_eq!(auth_header, "Bearer abc123");

        // Test no authentication
        let none_creds = RegistryCredentials::None;
        assert!(none_creds.to_auth_header().is_none());
    }

    #[test]
    fn test_registry_auth_configuration() {
        let mut auth = RegistryAuth::new();

        // Test default credentials
        auth.set_default_credentials(RegistryCredentials::Basic {
            username: "default_user".to_string(),
            password: "default_pass".to_string(),
        });

        // Test registry-specific credentials
        auth.set_credentials(
            "ghcr.io".to_string(),
            RegistryCredentials::Bearer {
                token: "ghcr_token".to_string(),
            },
        );

        // Test getting default credentials
        let creds = auth.get_credentials("unknown.registry");
        assert_eq!(
            creds,
            &RegistryCredentials::Basic {
                username: "default_user".to_string(),
                password: "default_pass".to_string(),
            }
        );

        // Test getting registry-specific credentials
        let creds = auth.get_credentials("ghcr.io");
        assert_eq!(
            creds,
            &RegistryCredentials::Bearer {
                token: "ghcr_token".to_string(),
            }
        );
    }

    #[tokio::test]
    async fn test_mock_http_client() {
        let client = MockHttpClient::new();
        let test_data = Bytes::from("test response");

        client
            .add_response("https://example.com/test".to_string(), test_data.clone())
            .await;

        let result = client.get("https://example.com/test").await.unwrap();
        assert_eq!(result, test_data);

        // Test non-existent URL
        let result = client.get("https://example.com/nonexistent").await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_retry_integration_with_manifest_fetch() {
        use std::sync::atomic::{AtomicU32, Ordering};
        use std::sync::Arc;

        // Mock client that fails first N attempts
        #[derive(Debug, Clone)]
        struct FailingMockClient {
            failure_count: Arc<AtomicU32>,
            fail_attempts: u32,
        }

        impl FailingMockClient {
            fn new(fail_attempts: u32) -> Self {
                Self {
                    failure_count: Arc::new(AtomicU32::new(0)),
                    fail_attempts,
                }
            }
        }

        #[async_trait::async_trait]
        impl HttpClient for FailingMockClient {
            async fn get(
                &self,
                _url: &str,
            ) -> std::result::Result<Bytes, Box<dyn std::error::Error + Send + Sync>> {
                let current = self.failure_count.fetch_add(1, Ordering::SeqCst);
                if current < self.fail_attempts {
                    Err("network error".into())
                } else {
                    // Return a valid manifest JSON after failures
                    let manifest = serde_json::json!({
                        "schemaVersion": 2,
                        "mediaType": "application/vnd.oci.image.manifest.v1+json",
                        "layers": [{
                            "mediaType": "application/vnd.oci.image.layer.v1.tar",
                            "size": 1024,
                            "digest": "sha256:abc123"
                        }]
                    });
                    Ok(Bytes::from(manifest.to_string()))
                }
            }

            async fn get_with_headers(
                &self,
                url: &str,
                _headers: HashMap<String, String>,
            ) -> std::result::Result<Bytes, Box<dyn std::error::Error + Send + Sync>> {
                self.get(url).await
            }

            async fn get_with_headers_and_response(
                &self,
                _url: &str,
                _headers: HashMap<String, String>,
            ) -> std::result::Result<HttpResponse, Box<dyn std::error::Error + Send + Sync>>
            {
                let current = self.failure_count.fetch_add(1, Ordering::SeqCst);
                if current < self.fail_attempts {
                    Err("network error".into())
                } else {
                    Ok(HttpResponse {
                        status: 200,
                        headers: HashMap::new(),
                        body: Bytes::new(),
                    })
                }
            }

            async fn head(
                &self,
                _url: &str,
                _headers: HashMap<String, String>,
            ) -> std::result::Result<u16, Box<dyn std::error::Error + Send + Sync>> {
                let current = self.failure_count.fetch_add(1, Ordering::SeqCst);
                if current < self.fail_attempts {
                    Err("network error".into())
                } else {
                    Ok(404)
                }
            }

            async fn put_with_headers(
                &self,
                _url: &str,
                _data: Bytes,
                _headers: HashMap<String, String>,
            ) -> std::result::Result<Bytes, Box<dyn std::error::Error + Send + Sync>> {
                let current = self.failure_count.fetch_add(1, Ordering::SeqCst);
                if current < self.fail_attempts {
                    Err("network error".into())
                } else {
                    Ok(Bytes::new())
                }
            }

            async fn post_with_headers(
                &self,
                _url: &str,
                _data: Bytes,
                _headers: HashMap<String, String>,
            ) -> std::result::Result<HttpResponse, Box<dyn std::error::Error + Send + Sync>>
            {
                let current = self.failure_count.fetch_add(1, Ordering::SeqCst);
                if current < self.fail_attempts {
                    Err("network error".into())
                } else {
                    Ok(HttpResponse {
                        status: 200,
                        headers: HashMap::new(),
                        body: Bytes::new(),
                    })
                }
            }
        }

        // Test that retry works - should succeed after 2 failures
        let client = FailingMockClient::new(2);
        let retry_config = crate::retry::RetryConfig {
            max_attempts: 3,
            base_delay: std::time::Duration::from_millis(1),
            max_delay: std::time::Duration::from_millis(10),
            jitter: crate::retry::JitterStrategy::FullJitter,
        };

        let fetcher = FeatureFetcher::with_retry_config(
            client.clone(),
            std::env::temp_dir().join("test-cache"),
            retry_config,
        );

        let feature_ref = FeatureRef::new(
            "test.registry".to_string(),
            "test".to_string(),
            "feature".to_string(),
            Some("v1.0".to_string()),
        );

        let result = fetcher.get_manifest(&feature_ref).await;
        assert!(result.is_ok());

        let manifest = result.unwrap();
        assert_eq!(manifest.layers.len(), 1);
        assert_eq!(manifest.layers[0].digest, "sha256:abc123");

        // Verify that it tried 3 times (initial + 2 retries)
        assert_eq!(client.failure_count.load(Ordering::SeqCst), 3);
    }

    #[tokio::test]
    async fn test_retry_gives_up_after_max_attempts() {
        use std::sync::atomic::{AtomicU32, Ordering};
        use std::sync::Arc;

        // Mock client that always fails
        #[derive(Debug, Clone)]
        struct AlwaysFailingClient {
            call_count: Arc<AtomicU32>,
        }

        impl AlwaysFailingClient {
            fn new() -> Self {
                Self {
                    call_count: Arc::new(AtomicU32::new(0)),
                }
            }
        }

        #[async_trait::async_trait]
        impl HttpClient for AlwaysFailingClient {
            async fn get(
                &self,
                _url: &str,
            ) -> std::result::Result<Bytes, Box<dyn std::error::Error + Send + Sync>> {
                self.call_count.fetch_add(1, Ordering::SeqCst);
                Err("permanent network error".into())
            }

            async fn get_with_headers(
                &self,
                url: &str,
                _headers: HashMap<String, String>,
            ) -> std::result::Result<Bytes, Box<dyn std::error::Error + Send + Sync>> {
                self.get(url).await
            }

            async fn get_with_headers_and_response(
                &self,
                _url: &str,
                _headers: HashMap<String, String>,
            ) -> std::result::Result<HttpResponse, Box<dyn std::error::Error + Send + Sync>>
            {
                self.call_count.fetch_add(1, Ordering::SeqCst);
                Err("permanent network error".into())
            }

            async fn head(
                &self,
                _url: &str,
                _headers: HashMap<String, String>,
            ) -> std::result::Result<u16, Box<dyn std::error::Error + Send + Sync>> {
                self.call_count.fetch_add(1, Ordering::SeqCst);
                Err("permanent network error".into())
            }

            async fn put_with_headers(
                &self,
                _url: &str,
                _data: Bytes,
                _headers: HashMap<String, String>,
            ) -> std::result::Result<Bytes, Box<dyn std::error::Error + Send + Sync>> {
                self.call_count.fetch_add(1, Ordering::SeqCst);
                Err("permanent network error".into())
            }

            async fn post_with_headers(
                &self,
                _url: &str,
                _data: Bytes,
                _headers: HashMap<String, String>,
            ) -> std::result::Result<HttpResponse, Box<dyn std::error::Error + Send + Sync>>
            {
                self.call_count.fetch_add(1, Ordering::SeqCst);
                Err("permanent network error".into())
            }
        }

        let client = AlwaysFailingClient::new();
        let retry_config = crate::retry::RetryConfig {
            max_attempts: 2,
            base_delay: std::time::Duration::from_millis(1),
            max_delay: std::time::Duration::from_millis(10),
            jitter: crate::retry::JitterStrategy::FullJitter,
        };

        let fetcher = FeatureFetcher::with_retry_config(
            client.clone(),
            std::env::temp_dir().join("test-cache"),
            retry_config,
        );

        let feature_ref = FeatureRef::new(
            "test.registry".to_string(),
            "test".to_string(),
            "feature".to_string(),
            Some("v1.0".to_string()),
        );

        let result = fetcher.get_manifest(&feature_ref).await;
        assert!(result.is_err());

        // Should have tried 3 times total (initial + 2 retries)
        assert_eq!(client.call_count.load(Ordering::SeqCst), 3);
    }

    #[test]
    fn test_error_classifier() {
        use crate::errors::FeatureError;

        // Test that network errors are retried
        let download_error = FeatureError::Download {
            message: "network timeout".to_string(),
        };
        assert_eq!(
            classify_network_error(&download_error),
            crate::retry::RetryDecision::Retry
        );

        let oci_error = FeatureError::Oci {
            message: "registry unavailable".to_string(),
        };
        assert_eq!(
            classify_network_error(&oci_error),
            crate::retry::RetryDecision::Retry
        );

        // Test that authentication errors are retried
        let auth_error = FeatureError::Authentication {
            message: "invalid credentials".to_string(),
        };
        assert_eq!(
            classify_network_error(&auth_error),
            crate::retry::RetryDecision::Retry
        );

        // Test that logical errors are not retried
        let parsing_error = FeatureError::Parsing {
            message: "invalid json".to_string(),
        };
        assert_eq!(
            classify_network_error(&parsing_error),
            crate::retry::RetryDecision::Stop
        );

        let validation_error = FeatureError::Validation {
            message: "missing field".to_string(),
        };
        assert_eq!(
            classify_network_error(&validation_error),
            crate::retry::RetryDecision::Stop
        );
    }

    #[test]
    fn test_get_features_cache_dir() {
        let cache_dir = get_features_cache_dir().expect("should get features cache dir");

        // Verify the cache directory is created and has the right structure
        assert!(cache_dir.exists());
        assert!(cache_dir.is_dir());
        assert!(cache_dir.ends_with("features"));

        // Verify it's using the persistent cache base directory
        let expected_base = crate::progress::get_cache_dir().expect("should get cache dir");
        let expected_features_cache = expected_base.join("features");
        assert_eq!(cache_dir, expected_features_cache);
    }

    #[test]
    fn test_feature_fetcher_uses_persistent_cache() {
        let mock_client = MockHttpClient::new();
        let fetcher = FeatureFetcher::new(mock_client);

        // The fetcher should use the persistent cache directory
        let expected_cache = get_features_cache_dir()
            .unwrap_or_else(|_| std::env::temp_dir().join("deacon-features"));

        assert_eq!(fetcher.cache_dir, expected_cache);
    }

    #[tokio::test]
    async fn test_publish_collection_metadata_success() {
        let mock_client = MockHttpClient::new();
        let cache_dir = std::env::temp_dir().join("test-publish-collection-cache");
        let retry_config = crate::retry::RetryConfig {
            max_attempts: 3,
            base_delay: std::time::Duration::from_millis(1),
            max_delay: std::time::Duration::from_millis(10),
            jitter: crate::retry::JitterStrategy::FullJitter,
        };

        let fetcher =
            FeatureFetcher::with_retry_config(mock_client.clone(), cache_dir.clone(), retry_config);

        let collection_json = Bytes::from(
            r#"{"sourceInformation":{"source":"test-collection","revision":"v1.0.0"},"features":[{"id":"test-feature","version":"1.0.0"}]}"#,
        );

        let registry = "test.registry";
        let namespace = "test-namespace";

        // Calculate expected digests
        let mut config_hasher = Sha256::new();
        config_hasher.update(&collection_json);
        let expected_config_digest = format!("sha256:{:x}", config_hasher.finalize());

        // Mock HEAD response for blob check (404 = not exists)
        let blob_check_url = format!(
            "https://{}/v2/{}/blobs/{}",
            registry, namespace, expected_config_digest
        );
        mock_client.add_head_response(blob_check_url, 404).await;

        // Mock POST response for upload initiation with Location header
        let upload_init_url = format!("https://{}/v2/{}/blobs/uploads/", registry, namespace);
        let upload_uuid = "550e8400-e29b-41d4-a716-446655440000";
        let location = format!("/v2/{}/blobs/uploads/{}", namespace, upload_uuid);
        let mut post_headers = HashMap::new();
        post_headers.insert("location".to_string(), location.clone());

        mock_client
            .add_response_with_headers(
                upload_init_url,
                HttpResponse {
                    status: 202,
                    headers: post_headers,
                    body: Bytes::from(""),
                },
            )
            .await;

        // Mock PUT response for blob upload completion
        let upload_complete_url = format!("{}?digest={}", location, expected_config_digest);
        mock_client
            .add_response(upload_complete_url, Bytes::from(""))
            .await;

        // Mock PUT response for manifest upload
        let manifest_url = format!("https://{}/v2/{}/manifests/collection", registry, namespace);
        mock_client
            .add_response(manifest_url.clone(), Bytes::from(""))
            .await;

        // Call publish_collection_metadata
        let result = fetcher
            .publish_collection_metadata(registry, namespace, collection_json.clone())
            .await;

        // Assert success
        assert!(result.is_ok(), "Expected success, got error: {:?}", result);
        let manifest_digest = result.unwrap();

        // Verify the manifest digest is a valid SHA256 digest
        assert!(manifest_digest.starts_with("sha256:"));
        assert_eq!(manifest_digest.len(), 71); // "sha256:" (7 chars) + 64 hex chars
    }

    #[tokio::test]
    async fn test_publish_collection_metadata_digest_correctness() {
        let mock_client = MockHttpClient::new();
        let cache_dir = std::env::temp_dir().join("test-digest-cache");
        let retry_config = crate::retry::RetryConfig {
            max_attempts: 1,
            base_delay: std::time::Duration::from_millis(1),
            max_delay: std::time::Duration::from_millis(10),
            jitter: crate::retry::JitterStrategy::FullJitter,
        };

        let fetcher =
            FeatureFetcher::with_retry_config(mock_client.clone(), cache_dir.clone(), retry_config);

        let collection_json = Bytes::from(r#"{"test":"data"}"#);
        let registry = "test.registry";
        let namespace = "test-namespace";

        // Manually calculate expected config digest
        let mut config_hasher = Sha256::new();
        config_hasher.update(&collection_json);
        let expected_config_digest = format!("sha256:{:x}", config_hasher.finalize());

        // Mock responses
        let blob_check_url = format!(
            "https://{}/v2/{}/blobs/{}",
            registry, namespace, expected_config_digest
        );
        mock_client.add_head_response(blob_check_url, 404).await;

        let upload_init_url = format!("https://{}/v2/{}/blobs/uploads/", registry, namespace);
        let location = format!("/v2/{}/blobs/uploads/test-uuid", namespace);
        let mut post_headers = HashMap::new();
        post_headers.insert("location".to_string(), location.clone());

        mock_client
            .add_response_with_headers(
                upload_init_url,
                HttpResponse {
                    status: 202,
                    headers: post_headers,
                    body: Bytes::from(""),
                },
            )
            .await;

        let upload_complete_url = format!("{}?digest={}", location, expected_config_digest);
        mock_client
            .add_response(upload_complete_url, Bytes::from(""))
            .await;

        let manifest_url = format!("https://{}/v2/{}/manifests/collection", registry, namespace);
        mock_client
            .add_response(manifest_url.clone(), Bytes::from(""))
            .await;

        // Call and verify
        let result = fetcher
            .publish_collection_metadata(registry, namespace, collection_json)
            .await;

        assert!(result.is_ok());
        let manifest_digest = result.unwrap();

        // The manifest digest should be computed correctly
        // We can't predict the exact value without building the manifest,
        // but we can verify it's a valid SHA256 digest
        assert!(manifest_digest.starts_with("sha256:"));
        assert_eq!(manifest_digest.len(), 71);
    }

    #[tokio::test]
    async fn test_publish_collection_metadata_upload_failure() {
        use std::sync::atomic::{AtomicU32, Ordering};
        use std::sync::Arc;

        // Mock client that always fails PUT requests for blob upload
        #[derive(Debug, Clone)]
        struct FailingUploadClient {
            call_count: Arc<AtomicU32>,
        }

        impl FailingUploadClient {
            fn new() -> Self {
                Self {
                    call_count: Arc::new(AtomicU32::new(0)),
                }
            }
        }

        #[async_trait::async_trait]
        impl HttpClient for FailingUploadClient {
            async fn get(
                &self,
                _url: &str,
            ) -> std::result::Result<Bytes, Box<dyn std::error::Error + Send + Sync>> {
                Ok(Bytes::new())
            }

            async fn get_with_headers(
                &self,
                url: &str,
                _headers: HashMap<String, String>,
            ) -> std::result::Result<Bytes, Box<dyn std::error::Error + Send + Sync>> {
                self.get(url).await
            }

            async fn get_with_headers_and_response(
                &self,
                url: &str,
                headers: HashMap<String, String>,
            ) -> std::result::Result<HttpResponse, Box<dyn std::error::Error + Send + Sync>>
            {
                let body = self.get_with_headers(url, headers).await?;
                Ok(HttpResponse {
                    status: 200,
                    headers: HashMap::new(),
                    body,
                })
            }

            async fn head(
                &self,
                _url: &str,
                _headers: HashMap<String, String>,
            ) -> std::result::Result<u16, Box<dyn std::error::Error + Send + Sync>> {
                Ok(404) // Blob doesn't exist
            }

            async fn put_with_headers(
                &self,
                _url: &str,
                _data: Bytes,
                _headers: HashMap<String, String>,
            ) -> std::result::Result<Bytes, Box<dyn std::error::Error + Send + Sync>> {
                self.call_count.fetch_add(1, Ordering::SeqCst);
                Err("network error during upload".into())
            }

            async fn post_with_headers(
                &self,
                _url: &str,
                _data: Bytes,
                _headers: HashMap<String, String>,
            ) -> std::result::Result<HttpResponse, Box<dyn std::error::Error + Send + Sync>>
            {
                // Return valid upload initiation response
                let mut headers = HashMap::new();
                headers.insert(
                    "location".to_string(),
                    "/v2/test/blobs/uploads/uuid".to_string(),
                );
                Ok(HttpResponse {
                    status: 202,
                    headers,
                    body: Bytes::new(),
                })
            }
        }

        let client = FailingUploadClient::new();
        let cache_dir = std::env::temp_dir().join("test-upload-failure-cache");
        let retry_config = crate::retry::RetryConfig {
            max_attempts: 2,
            base_delay: std::time::Duration::from_millis(1),
            max_delay: std::time::Duration::from_millis(10),
            jitter: crate::retry::JitterStrategy::FullJitter,
        };

        let fetcher = FeatureFetcher::with_retry_config(client.clone(), cache_dir, retry_config);

        let collection_json = Bytes::from(r#"{"test":"data"}"#);
        let result = fetcher
            .publish_collection_metadata("test.registry", "test-namespace", collection_json)
            .await;

        // Should fail after retries
        assert!(result.is_err());
        let err = result.unwrap_err();
        assert!(matches!(err, crate::errors::DeaconError::Feature(_)));

        // Should have retried (initial + 2 retries = 3 attempts)
        assert_eq!(client.call_count.load(Ordering::SeqCst), 3);
    }

    #[tokio::test]
    async fn test_publish_collection_metadata_retry_success() {
        use std::sync::atomic::{AtomicU32, Ordering};
        use std::sync::Arc;

        // Mock client that fails first 2 attempts then succeeds
        #[derive(Debug, Clone)]
        struct RetryableClient {
            put_call_count: Arc<AtomicU32>,
            fail_attempts: u32,
        }

        impl RetryableClient {
            fn new(fail_attempts: u32) -> Self {
                Self {
                    put_call_count: Arc::new(AtomicU32::new(0)),
                    fail_attempts,
                }
            }
        }

        #[async_trait::async_trait]
        impl HttpClient for RetryableClient {
            async fn get(
                &self,
                _url: &str,
            ) -> std::result::Result<Bytes, Box<dyn std::error::Error + Send + Sync>> {
                Ok(Bytes::new())
            }

            async fn get_with_headers(
                &self,
                url: &str,
                _headers: HashMap<String, String>,
            ) -> std::result::Result<Bytes, Box<dyn std::error::Error + Send + Sync>> {
                self.get(url).await
            }

            async fn get_with_headers_and_response(
                &self,
                url: &str,
                headers: HashMap<String, String>,
            ) -> std::result::Result<HttpResponse, Box<dyn std::error::Error + Send + Sync>>
            {
                let body = self.get_with_headers(url, headers).await?;
                Ok(HttpResponse {
                    status: 200,
                    headers: HashMap::new(),
                    body,
                })
            }

            async fn head(
                &self,
                _url: &str,
                _headers: HashMap<String, String>,
            ) -> std::result::Result<u16, Box<dyn std::error::Error + Send + Sync>> {
                Ok(404)
            }

            async fn put_with_headers(
                &self,
                _url: &str,
                _data: Bytes,
                _headers: HashMap<String, String>,
            ) -> std::result::Result<Bytes, Box<dyn std::error::Error + Send + Sync>> {
                let current = self.put_call_count.fetch_add(1, Ordering::SeqCst);
                if current < self.fail_attempts {
                    Err("transient network error".into())
                } else {
                    Ok(Bytes::new())
                }
            }

            async fn post_with_headers(
                &self,
                _url: &str,
                _data: Bytes,
                _headers: HashMap<String, String>,
            ) -> std::result::Result<HttpResponse, Box<dyn std::error::Error + Send + Sync>>
            {
                let mut headers = HashMap::new();
                headers.insert(
                    "location".to_string(),
                    "/v2/test/blobs/uploads/uuid".to_string(),
                );
                Ok(HttpResponse {
                    status: 202,
                    headers,
                    body: Bytes::new(),
                })
            }
        }

        let client = RetryableClient::new(2); // Fail first 2 attempts
        let cache_dir = std::env::temp_dir().join("test-retry-success-cache");
        let retry_config = crate::retry::RetryConfig {
            max_attempts: 3,
            base_delay: std::time::Duration::from_millis(1),
            max_delay: std::time::Duration::from_millis(10),
            jitter: crate::retry::JitterStrategy::FullJitter,
        };

        let fetcher = FeatureFetcher::with_retry_config(client.clone(), cache_dir, retry_config);

        let collection_json = Bytes::from(r#"{"test":"data"}"#);
        let result = fetcher
            .publish_collection_metadata("test.registry", "test-namespace", collection_json)
            .await;

        // Should succeed after retries
        assert!(
            result.is_ok(),
            "Expected success after retries, got: {:?}",
            result
        );

        // Should have tried 3 times for blob upload, then 1 time for manifest upload = 4 total
        // (first 2 blob uploads fail, 3rd succeeds, then manifest succeeds on first try)
        let total_calls = client.put_call_count.load(Ordering::SeqCst);
        assert_eq!(
            total_calls, 4,
            "Expected 4 PUT calls (3 for blob + 1 for manifest)"
        );
    }

    #[tokio::test]
    async fn test_publish_collection_metadata_authentication_error() {
        use std::sync::atomic::{AtomicBool, Ordering};
        use std::sync::Arc;

        // Mock client that returns authentication error
        #[derive(Debug, Clone)]
        struct AuthFailClient {
            auth_error_triggered: Arc<AtomicBool>,
        }

        impl AuthFailClient {
            fn new() -> Self {
                Self {
                    auth_error_triggered: Arc::new(AtomicBool::new(false)),
                }
            }
        }

        #[async_trait::async_trait]
        impl HttpClient for AuthFailClient {
            async fn get(
                &self,
                _url: &str,
            ) -> std::result::Result<Bytes, Box<dyn std::error::Error + Send + Sync>> {
                Ok(Bytes::new())
            }

            async fn get_with_headers(
                &self,
                url: &str,
                _headers: HashMap<String, String>,
            ) -> std::result::Result<Bytes, Box<dyn std::error::Error + Send + Sync>> {
                self.get(url).await
            }

            async fn get_with_headers_and_response(
                &self,
                url: &str,
                headers: HashMap<String, String>,
            ) -> std::result::Result<HttpResponse, Box<dyn std::error::Error + Send + Sync>>
            {
                let body = self.get_with_headers(url, headers).await?;
                Ok(HttpResponse {
                    status: 200,
                    headers: HashMap::new(),
                    body,
                })
            }

            async fn head(
                &self,
                _url: &str,
                _headers: HashMap<String, String>,
            ) -> std::result::Result<u16, Box<dyn std::error::Error + Send + Sync>> {
                Ok(404)
            }

            async fn put_with_headers(
                &self,
                url: &str,
                _data: Bytes,
                _headers: HashMap<String, String>,
            ) -> std::result::Result<Bytes, Box<dyn std::error::Error + Send + Sync>> {
                // Fail manifest upload with authentication error
                if url.contains("/manifests/collection") {
                    self.auth_error_triggered.store(true, Ordering::SeqCst);
                    Err("Authentication failed: invalid credentials".into())
                } else {
                    // Blob upload succeeds
                    Ok(Bytes::new())
                }
            }

            async fn post_with_headers(
                &self,
                _url: &str,
                _data: Bytes,
                _headers: HashMap<String, String>,
            ) -> std::result::Result<HttpResponse, Box<dyn std::error::Error + Send + Sync>>
            {
                let mut headers = HashMap::new();
                headers.insert(
                    "location".to_string(),
                    "/v2/test/blobs/uploads/uuid".to_string(),
                );
                Ok(HttpResponse {
                    status: 202,
                    headers,
                    body: Bytes::new(),
                })
            }
        }

        let client = AuthFailClient::new();
        let cache_dir = std::env::temp_dir().join("test-auth-error-cache");
        let retry_config = crate::retry::RetryConfig {
            max_attempts: 2,
            base_delay: std::time::Duration::from_millis(1),
            max_delay: std::time::Duration::from_millis(10),
            jitter: crate::retry::JitterStrategy::FullJitter,
        };

        let fetcher = FeatureFetcher::with_retry_config(client.clone(), cache_dir, retry_config);

        let collection_json = Bytes::from(r#"{"test":"data"}"#);
        let result = fetcher
            .publish_collection_metadata("test.registry", "test-namespace", collection_json)
            .await;

        // Should fail with authentication error
        assert!(result.is_err());
        let err = result.unwrap_err();

        // Verify it's a Feature error with Authentication variant
        match err {
            crate::errors::DeaconError::Feature(feature_err) => match feature_err {
                FeatureError::Authentication { message } => {
                    assert!(message.contains("authenticate"));
                }
                _ => panic!("Expected Authentication error, got: {:?}", feature_err),
            },
            _ => panic!("Expected Feature error, got: {:?}", err),
        }

        // Verify authentication error was triggered
        assert!(client.auth_error_triggered.load(Ordering::SeqCst));
    }
}
