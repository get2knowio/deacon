use serde::{Deserialize, Serialize};
use std::path::PathBuf;

/// A collection of feature sources and tests on disk.
///
/// This struct represents the root of a features test collection and contains
/// resolved absolute paths for the collection root, `src/` and `test/`
/// directories as well as a stable `id` derived from the collection path.
#[derive(Debug, Clone)]
pub struct TestCollection {
    /// Stable identifier for the collection (derived from the canonical path)
    id: String,
    /// Absolute path to the collection root
    root_path: PathBuf,
    /// Absolute path to the `src/` directory
    src_path: PathBuf,
    /// Absolute path to the `test/` directory
    test_path: PathBuf,
}

impl TestCollection {
    /// Creates a new TestCollection.
    ///
    /// # Arguments
    ///
    /// * `id` - Stable identifier for the collection
    /// * `root_path` - Absolute path to the collection root
    /// * `src_path` - Absolute path to the `src/` directory
    /// * `test_path` - Absolute path to the `test/` directory
    pub fn new(id: String, root_path: PathBuf, src_path: PathBuf, test_path: PathBuf) -> Self {
        Self {
            id,
            root_path,
            src_path,
            test_path,
        }
    }

    /// Returns the collection's stable identifier.
    pub fn id(&self) -> &str {
        &self.id
    }

    /// Returns the absolute path to the collection root.
    pub fn root_path(&self) -> &PathBuf {
        &self.root_path
    }

    /// Returns the absolute path to the `src/` directory.
    pub fn src_path(&self) -> &PathBuf {
        &self.src_path
    }

    /// Returns the absolute path to the `test/` directory.
    pub fn test_path(&self) -> &PathBuf {
        &self.test_path
    }
}

/// A feature discovered inside a `TestCollection`.
///
/// Contains the feature id (directory name), paths to its source and test
/// directories, a flag indicating whether tests are autogenerated, and the
/// list of discovered scenarios for the feature.
#[derive(Debug, Clone)]
pub struct Feature {
    /// Feature identifier (directory name)
    id: String,
    /// Path to the feature source directory (`src/<feature>`)
    src_dir: PathBuf,
    /// Path to the feature test directory (`test/<feature>`)
    test_dir: PathBuf,
    /// True when the feature has an autogenerated `test.sh` in its test dir
    has_autogenerated: bool,
    /// Discovered scenarios for this feature
    scenarios: Vec<Scenario>,
}

impl Feature {
    /// Creates a new Feature.
    ///
    /// # Arguments
    ///
    /// * `id` - Feature identifier (directory name)
    /// * `src_dir` - Path to the feature source directory
    /// * `test_dir` - Path to the feature test directory
    /// * `has_autogenerated` - Whether the feature has an autogenerated test.sh
    /// * `scenarios` - Discovered scenarios for this feature
    pub fn new(
        id: String,
        src_dir: PathBuf,
        test_dir: PathBuf,
        has_autogenerated: bool,
        scenarios: Vec<Scenario>,
    ) -> Self {
        Self {
            id,
            src_dir,
            test_dir,
            has_autogenerated,
            scenarios,
        }
    }

    /// Returns the feature identifier.
    pub fn id(&self) -> &str {
        &self.id
    }

    /// Returns the path to the feature source directory.
    pub fn src_dir(&self) -> &PathBuf {
        &self.src_dir
    }

    /// Returns the path to the feature test directory.
    pub fn test_dir(&self) -> &PathBuf {
        &self.test_dir
    }

    /// Returns whether the feature has an autogenerated test.sh.
    pub fn has_autogenerated(&self) -> bool {
        self.has_autogenerated
    }

    /// Returns the discovered scenarios for this feature.
    pub fn scenarios(&self) -> &[Scenario] {
        &self.scenarios
    }
}

/// A single test scenario.
///
/// Scenarios may be feature-scoped or global (feature_id == "_global"). Each
/// scenario contains the scenario name, the script path to execute and an
/// optional configuration file path.
#[derive(Debug, Clone)]
pub struct Scenario {
    /// Owning feature id (or "_global" for global scenarios)
    feature_id: String, // or "_global"
    /// Scenario name (used to compose test names)
    name: String,
    /// Path to the script that implements the scenario
    script_path: PathBuf,
    /// Optional path to a scenario-specific configuration file
    config_path: Option<PathBuf>,
}

impl Scenario {
    /// Creates a new Scenario.
    ///
    /// # Arguments
    ///
    /// * `feature_id` - Owning feature id (or "_global" for global scenarios)
    /// * `name` - Scenario name (used to compose test names)
    /// * `script_path` - Path to the script that implements the scenario
    /// * `config_path` - Optional path to a scenario-specific configuration file
    pub fn new(
        feature_id: String,
        name: String,
        script_path: PathBuf,
        config_path: Option<PathBuf>,
    ) -> Self {
        Self {
            feature_id,
            name,
            script_path,
            config_path,
        }
    }

    /// Returns the owning feature id (or "_global" for global scenarios).
    pub fn feature_id(&self) -> &str {
        &self.feature_id
    }

    /// Returns the scenario name.
    pub fn name(&self) -> &str {
        &self.name
    }

    /// Returns the path to the scenario script.
    pub fn script_path(&self) -> &PathBuf {
        &self.script_path
    }

    /// Returns the optional path to a scenario-specific configuration file.
    pub fn config_path(&self) -> Option<&PathBuf> {
        self.config_path.as_ref()
    }
}

/// Result of a single test execution.
///
/// Serialized to/from JSON when reporting results.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestResult {
    /// Test name (e.g. "feature:scenario" or "_global:scenario")
    #[serde(rename = "testName")]
    test_name: String,
    /// true when the test passed (exit code 0)
    result: bool,
}

impl TestResult {
    /// Creates a new TestResult.
    ///
    /// # Arguments
    ///
    /// * `test_name` - Test name (e.g. "feature:scenario" or "_global:scenario")
    /// * `result` - true when the test passed (exit code 0)
    pub fn new(test_name: String, result: bool) -> Self {
        Self { test_name, result }
    }

    /// Returns the test name.
    pub fn test_name(&self) -> &str {
        &self.test_name
    }

    /// Returns whether the test passed.
    pub fn result(&self) -> bool {
        self.result
    }
}

/// Configuration for executing a set of tests.
///
/// This structure holds the user-specified options that control which
/// features/scenarios to run and runtime options such as the base image,
/// preservation of containers, and logging verbosity.
#[derive(Debug, Clone)]
pub struct TestRun {
    /// Optional list of feature ids to restrict the run to
    selected_features: Option<Vec<String>>,
    /// Optional substring filter for scenario names (case-sensitive)
    filter: Option<String>,
    /// Run only global scenarios when true
    global_only: bool,
    /// Skip reading scenarios.json and only run autogenerated tests
    skip_scenarios: bool,
    /// Skip features that have autogenerated tests
    skip_autogenerated: bool,
    /// Skip duplicate/idempotence checks
    skip_duplicated: bool,
    /// Allow randomized ordering when true
    permit_randomization: bool,
    /// Base image to use when creating test containers
    base_image: String,
    /// Optional remote user to execute scripts as inside the container
    remote_user: Option<String>,
    /// When true, test containers are preserved after the run
    preserve: bool,
    /// Suppress non-error output when true
    quiet: bool,
    /// Desired log verbosity
    log_level: LogLevel,
}

impl TestRun {
    /// Creates a new TestRun with all configuration options.
    ///
    /// # Arguments
    ///
    /// * `selected_features` - Optional list of feature ids to restrict the run to
    /// * `filter` - Optional substring filter for scenario names (case-sensitive)
    /// * `global_only` - Run only global scenarios when true
    /// * `skip_scenarios` - Skip reading scenarios.json and only run autogenerated tests
    /// * `skip_autogenerated` - Skip features that have autogenerated tests
    /// * `skip_duplicated` - Skip duplicate/idempotence checks
    /// * `permit_randomization` - Allow randomized ordering when true
    /// * `base_image` - Base image to use when creating test containers
    /// * `remote_user` - Optional remote user to execute scripts as inside the container
    /// * `preserve` - When true, test containers are preserved after the run
    /// * `quiet` - Suppress non-error output when true
    /// * `log_level` - Desired log verbosity
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        selected_features: Option<Vec<String>>,
        filter: Option<String>,
        global_only: bool,
        skip_scenarios: bool,
        skip_autogenerated: bool,
        skip_duplicated: bool,
        permit_randomization: bool,
        base_image: String,
        remote_user: Option<String>,
        preserve: bool,
        quiet: bool,
        log_level: LogLevel,
    ) -> Self {
        Self {
            selected_features,
            filter,
            global_only,
            skip_scenarios,
            skip_autogenerated,
            skip_duplicated,
            permit_randomization,
            base_image,
            remote_user,
            preserve,
            quiet,
            log_level,
        }
    }

    /// Returns the optional list of feature ids to restrict the run to.
    pub fn selected_features(&self) -> Option<&Vec<String>> {
        self.selected_features.as_ref()
    }

    /// Returns the optional substring filter for scenario names.
    pub fn filter(&self) -> Option<&String> {
        self.filter.as_ref()
    }

    /// Returns whether to run only global scenarios.
    pub fn global_only(&self) -> bool {
        self.global_only
    }

    /// Returns whether to skip reading scenarios.json.
    pub fn skip_scenarios(&self) -> bool {
        self.skip_scenarios
    }

    /// Returns whether to skip features with autogenerated tests.
    pub fn skip_autogenerated(&self) -> bool {
        self.skip_autogenerated
    }

    /// Returns whether to skip duplicate/idempotence checks.
    pub fn skip_duplicated(&self) -> bool {
        self.skip_duplicated
    }

    /// Returns whether randomized ordering is permitted.
    pub fn permit_randomization(&self) -> bool {
        self.permit_randomization
    }

    /// Returns the base image to use when creating test containers.
    pub fn base_image(&self) -> &str {
        &self.base_image
    }

    /// Returns the optional remote user to execute scripts as.
    pub fn remote_user(&self) -> Option<&String> {
        self.remote_user.as_ref()
    }

    /// Returns whether test containers should be preserved after the run.
    pub fn preserve(&self) -> bool {
        self.preserve
    }

    /// Returns whether non-error output should be suppressed.
    pub fn quiet(&self) -> bool {
        self.quiet
    }

    /// Returns the desired log verbosity.
    pub fn log_level(&self) -> LogLevel {
        self.log_level
    }
}

/// Verbosity levels for features-test logging.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum LogLevel {
    /// Default level: information and warnings
    #[default]
    Info,
    /// Debug-level logging
    Debug,
    /// Most verbose trace logging
    Trace,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_result_serializes_with_camel_case_keys() {
        let result = TestResult::new("a:b".to_string(), true);
        let json = serde_json::to_string(&result).expect("serialization failed");

        // Verify that the JSON contains camelCase key "testName"
        assert!(
            json.contains("\"testName\""),
            "JSON should contain 'testName' key"
        );
        // Verify that the JSON does NOT contain snake_case key "test_name"
        assert!(
            !json.contains("\"test_name\""),
            "JSON should not contain 'test_name' key"
        );
        // Verify that the JSON contains "result" key
        assert!(
            json.contains("\"result\""),
            "JSON should contain 'result' key"
        );

        // Verify exact structure
        let parsed: serde_json::Value = serde_json::from_str(&json).expect("parsing failed");
        assert_eq!(parsed["testName"], "a:b");
        assert_eq!(parsed["result"], true);
    }

    #[test]
    fn test_result_array_serializes_correctly() {
        let results = vec![
            TestResult::new("feature1:scenario1".to_string(), true),
            TestResult::new("feature2:scenario2".to_string(), false),
        ];
        let json = serde_json::to_string(&results).expect("serialization failed");

        // Verify array structure
        assert!(json.starts_with('['));
        assert!(json.ends_with(']'));
        assert!(json.contains("\"testName\""));
        assert!(!json.contains("\"test_name\""));

        // Verify exact structure
        let parsed: Vec<serde_json::Value> = serde_json::from_str(&json).expect("parsing failed");
        assert_eq!(parsed.len(), 2);
        assert_eq!(parsed[0]["testName"], "feature1:scenario1");
        assert_eq!(parsed[0]["result"], true);
        assert_eq!(parsed[1]["testName"], "feature2:scenario2");
        assert_eq!(parsed[1]["result"], false);
    }

    #[test]
    fn test_empty_results_array_serializes_as_empty_json_array() {
        let results: Vec<TestResult> = vec![];
        let json = serde_json::to_string(&results).expect("serialization failed");
        assert_eq!(json, "[]");
    }
}
