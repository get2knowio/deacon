//! Test execution engine for running feature tests in Docker containers.
//!
//! This module provides functions to execute different types of feature tests:
//! - **Autogenerated tests**: Execute `test.sh` from a feature's test directory
//! - **Duplicate/idempotence tests**: Run `install.sh` twice to verify idempotence
//! - **Scenario tests**: Execute custom test scripts defined in `scenarios.json`
//!
//! All tests run in isolated Docker containers created from a base image. Containers
//! are automatically cleaned up after test execution unless the preserve flag is set.
//!
//! # Container Lifecycle
//!
//! 1. Create container from base image with label `devcontainer.is_test_run=true`
//! 2. Start the container
//! 3. Copy test script into container
//! 4. Execute script and capture exit code
//! 5. Cleanup container (unless `preserve` flag is set)
//!
//! # Tracing
//!
//! All test execution functions are instrumented with `tracing` spans for observability.

use crate::docker::{CliDocker, Docker, ExecConfig};
use crate::features_test::model::{Feature, Scenario, TestResult, TestRun};
use std::collections::HashMap;
use std::fs;
use std::path::Path;
use tracing::{debug, instrument};

const RUNTIME_UNAVAILABLE_ENV: &str = "DEACON_FORCE_RUNTIME_UNAVAILABLE";

fn check_forced_runtime_unavailable() -> Result<(), crate::features_test::errors::Error> {
    if std::env::var(RUNTIME_UNAVAILABLE_ENV).ok().as_deref() == Some("1") {
        return Err(crate::features_test::errors::Error::RuntimeUnavailable(
            "Forced by DEACON_FORCE_RUNTIME_UNAVAILABLE".to_string(),
        ));
    }
    Ok(())
}

/// Executes the autogenerated test for a feature.
///
/// Autogenerated tests verify that a feature's `test.sh` script runs successfully.
/// This is the primary test type for features and validates basic functionality.
///
/// # Process
///
/// 1. Validates that `test.sh` exists in the feature's test directory
/// 2. Creates a Docker container from the base image
/// 3. Copies and executes `test.sh` in the container
/// 4. Returns pass/fail based on the script's exit code
/// 5. Cleans up the container unless `preserve` flag is set
///
/// # Arguments
///
/// * `feature` - The feature to test (must have `has_autogenerated == true`)
/// * `test_run` - Test run configuration including base image and runtime settings
///
/// # Returns
///
/// Returns a [`TestResult`] with the test name (feature ID) and pass/fail status.
///
/// # Errors
///
/// Returns an error if:
/// - The `test.sh` script does not exist
/// - Docker is unavailable or fails to create/start the container
/// - The script cannot be copied to or executed in the container
/// - The environment variable `DEACON_FORCE_RUNTIME_UNAVAILABLE=1` is set (test hook)
///
/// # Example
///
/// ```no_run
/// use deacon_core::features_test::model::{Feature, TestRun, LogLevel};
/// use deacon_core::features_test::runner::execute_autogenerated_test;
/// use std::path::PathBuf;
///
/// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
/// let feature = Feature::new(
///     "color".to_string(),
///     PathBuf::from("/features/src/color"),
///     PathBuf::from("/features/test/color"),
///     true,
///     Vec::new(),
/// );
///
/// let test_run = TestRun::new(
///     None,
///     None,
///     false,
///     false,
///     false,
///     false,
///     false,
///     "ubuntu:22.04".to_string(),
///     None,
///     false,
///     false,
///     LogLevel::Info,
/// );
///
/// let result = execute_autogenerated_test(&feature, &test_run).await?;
/// println!("Test {} {}", result.test_name(), if result.result() { "passed" } else { "failed" });
/// # Ok(())
/// # }
/// ```
#[instrument(
    name = "feature.test",
    skip(feature, test_run),
    fields(
        feature_id = %feature.id(),
        test_type = "autogenerated",
        base_image = %test_run.base_image()
    )
)]
pub async fn execute_autogenerated_test(
    feature: &Feature,
    test_run: &TestRun,
) -> Result<TestResult, crate::features_test::errors::Error> {
    let test_name = feature.id().to_string();
    debug!("Executing autogenerated test for feature: {}", feature.id());

    // Verify test.sh exists
    let test_script_path = feature.test_dir().join("test.sh");
    if !test_script_path.exists() {
        return Err(crate::features_test::errors::Error::MissingTestScript(
            format!("test.sh not found at {:?}", test_script_path),
        ));
    }

    // Optional test hook: force runtime unavailable for tests
    check_forced_runtime_unavailable()?;

    // Create Docker client
    let docker = CliDocker::new();

    // Check Docker is available
    docker
        .ping()
        .await
        .map_err(|e| crate::features_test::errors::Error::RuntimeUnavailable(e.to_string()))?;

    // Create a container from the base image
    let container_id = create_test_container(&docker, test_run.base_image(), feature.id()).await?;

    // Execute the test script
    let result = execute_script_in_container(
        &docker,
        &container_id,
        &test_script_path,
        test_run.remote_user().map(|s| s.as_str()),
    )
    .await;

    // Cleanup container unless preserve flag is set
    if !test_run.preserve() {
        cleanup_container(&docker, &container_id).await?;
    }

    let success = result?;

    Ok(TestResult::new(test_name, success))
}

/// Executes the duplicate/idempotence test for a feature.
///
/// This test verifies that a feature's `install.sh` script can be run multiple times
/// without errors, ensuring proper duplicate/idempotence. Both executions must succeed for the
/// test to pass.
///
/// # Process
///
/// 1. Validates that `install.sh` exists in the feature's source directory
/// 2. Creates a Docker container from the base image
/// 3. Executes `install.sh` the first time
/// 4. If successful, executes `install.sh` a second time
/// 5. Returns pass only if both executions succeed
/// 6. Cleans up the container unless `preserve` flag is set
///
/// # Arguments
///
/// * `feature` - The feature to test
/// * `test_run` - Test run configuration
///
/// # Returns
///
/// Returns a [`TestResult`] with the test name (feature ID + " (duplicate/idempotence)") and pass/fail
/// status. The test passes only if both executions return exit code 0.
///
/// # Errors
///
/// Returns an error if:
/// - The `install.sh` script does not exist
/// - Docker is unavailable or fails to create/start the container
/// - The script cannot be copied to or executed in the container
/// - The environment variable `DEACON_FORCE_RUNTIME_UNAVAILABLE=1` is set (test hook)
///
/// # Example
///
/// ```no_run
/// use deacon_core::features_test::model::{Feature, TestRun, LogLevel};
/// use deacon_core::features_test::runner::execute_duplicate_test;
/// use std::path::PathBuf;
///
/// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
/// let feature = Feature::new(
///     "node".to_string(),
///     PathBuf::from("/features/src/node"),
///     PathBuf::from("/features/test/node"),
///     true,
///     Vec::new(),
/// );
///
/// let test_run = TestRun::new(
///     None,
///     None,
///     false,
///     false,
///     false,
///     false,
///     false,
///     "ubuntu:22.04".to_string(),
///     None,
///     false,
///     false,
///     LogLevel::Info,
/// );
///
/// let result = execute_duplicate_test(&feature, &test_run).await?;
/// assert!(result.test_name().ends_with("(duplicate/idempotence)"));
/// # Ok(())
/// # }
/// ```
#[instrument(
    name = "feature.test",
    skip(feature, test_run),
    fields(
        feature_id = %feature.id(),
        test_type = "duplicate",
        base_image = %test_run.base_image()
    )
)]
pub async fn execute_duplicate_test(
    feature: &Feature,
    test_run: &TestRun,
) -> Result<TestResult, crate::features_test::errors::Error> {
    let test_name = format!("{} (duplicate/idempotence)", feature.id());
    debug!(
        "Executing duplicate/idempotence test for feature: {}",
        feature.id()
    );

    // Verify install.sh exists in src directory
    let install_script_path = feature.src_dir().join("install.sh");
    if !install_script_path.exists() {
        return Err(crate::features_test::errors::Error::MissingTestScript(
            format!("install.sh not found at {:?}", install_script_path),
        ));
    }

    // Optional test hook: force runtime unavailable for tests
    check_forced_runtime_unavailable()?;

    // Create Docker client
    let docker = CliDocker::new();

    // Check Docker is available
    docker
        .ping()
        .await
        .map_err(|e| crate::features_test::errors::Error::RuntimeUnavailable(e.to_string()))?;

    // Create a container from the base image
    let container_id = create_test_container(
        &docker,
        test_run.base_image(),
        &format!("{}-dup", feature.id()),
    )
    .await?;

    // Execute install script twice
    let first_run = execute_script_in_container(
        &docker,
        &container_id,
        &install_script_path,
        test_run.remote_user().map(|s| s.as_str()),
    )
    .await;

    let second_run = if matches!(first_run.as_ref(), Ok(&true)) {
        execute_script_in_container(
            &docker,
            &container_id,
            &install_script_path,
            test_run.remote_user().map(|s| s.as_str()),
        )
        .await
    } else {
        Ok(false) // First run failed, skip second
    };

    // Cleanup container unless preserve flag is set
    if !test_run.preserve() {
        cleanup_container(&docker, &container_id).await?;
    }

    // Both runs must succeed for duplicate/idempotence test to pass
    let success = first_run? && second_run?;

    Ok(TestResult::new(test_name, success))
}

/// Executes a scenario test.
///
/// Scenario tests run custom test scripts defined in a feature's `scenarios.json` file.
/// These allow for more complex testing beyond basic installation validation.
///
/// # Process
///
/// 1. Validates that the scenario's script exists
/// 2. Creates a Docker container from the base image
/// 3. Copies and executes the scenario script in the container
/// 4. Returns pass/fail based on the script's exit code
/// 5. Cleans up the container unless `preserve` flag is set
///
/// # Arguments
///
/// * `scenario` - The scenario to test
/// * `test_run` - Test run configuration
///
/// # Returns
///
/// Returns a [`TestResult`] with the test name formatted as:
/// - `feature_id:scenario_name` for feature-specific scenarios
/// - `_global:scenario_name` for global scenarios
///
/// # Errors
///
/// Returns an error if:
/// - The scenario script does not exist
/// - Docker is unavailable or fails to create/start the container
/// - The script cannot be copied to or executed in the container
/// - The environment variable `DEACON_FORCE_RUNTIME_UNAVAILABLE=1` is set (test hook)
///
/// # Example
///
/// ```no_run
/// use deacon_core::features_test::model::{Scenario, TestRun, LogLevel};
/// use deacon_core::features_test::runner::execute_scenario_test;
/// use std::path::PathBuf;
///
/// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
/// let scenario = Scenario::new(
///     "color".to_string(),
///     "with-options".to_string(),
///     PathBuf::from("/features/test/color/with-options.sh"),
///     Some(PathBuf::from("/features/test/color/with-options.jsonc")),
/// );
///
/// let test_run = TestRun::new(
///     None,
///     None,
///     false,
///     false,
///     false,
///     false,
///     false,
///     "ubuntu:22.04".to_string(),
///     None,
///     false,
///     false,
///     LogLevel::Info,
/// );
///
/// let result = execute_scenario_test(&scenario, &test_run).await?;
/// assert_eq!(result.test_name(), "color:with-options");
/// # Ok(())
/// # }
/// ```
#[instrument(
    name = "scenario.run",
    skip(scenario, test_run),
    fields(
        feature_id = %scenario.feature_id(),
        scenario_name = %scenario.name(),
        base_image = %test_run.base_image()
    )
)]
pub async fn execute_scenario_test(
    scenario: &Scenario,
    test_run: &TestRun,
) -> Result<TestResult, crate::features_test::errors::Error> {
    let test_name = if scenario.feature_id() == "_global" {
        format!("_global:{}", scenario.name())
    } else {
        format!("{}:{}", scenario.feature_id(), scenario.name())
    };

    debug!("Executing scenario test: {}", test_name);

    // Verify scenario script exists
    if !scenario.script_path().exists() {
        return Err(crate::features_test::errors::Error::MissingTestScript(
            format!("Scenario script not found at {:?}", scenario.script_path()),
        ));
    }

    // Optional test hook: force runtime unavailable for tests
    check_forced_runtime_unavailable()?;

    // Create Docker client
    let docker = CliDocker::new();

    // Check Docker is available
    docker
        .ping()
        .await
        .map_err(|e| crate::features_test::errors::Error::RuntimeUnavailable(e.to_string()))?;

    // Create a container from the base image
    let container_id = create_test_container(
        &docker,
        test_run.base_image(),
        &format!("{}-scenario", scenario.name()),
    )
    .await?;

    // Execute the scenario script
    let result = execute_script_in_container(
        &docker,
        &container_id,
        scenario.script_path(),
        test_run.remote_user().map(|s| s.as_str()),
    )
    .await;

    // Cleanup container unless preserve flag is set
    if !test_run.preserve() {
        cleanup_container(&docker, &container_id).await?;
    }

    let success = result?;

    Ok(TestResult::new(test_name, success))
}

/// Creates a test container with appropriate labels.
///
/// Creates and starts a Docker container from the specified base image with a label
/// `devcontainer.is_test_run=true` for tracking and cleanup. The container runs
/// `sleep infinity` to keep it alive during test execution.
///
/// # Arguments
///
/// * `_docker` - Docker client (not currently used, kept for future enhancements)
/// * `base_image` - Base image to use for the container
/// * `name_suffix` - Suffix to add to container name for identification
///
/// # Returns
///
/// Returns the container ID as a String.
///
/// # Errors
///
/// Returns an error if the container cannot be created or started.
async fn create_test_container(
    _docker: &CliDocker,
    base_image: &str,
    name_suffix: &str,
) -> Result<String, crate::features_test::errors::Error> {
    debug!("Creating test container from image: {}", base_image);
    let unique_name = unique_identifier(&format!("deacon-test-{}", name_suffix));

    // Use docker CLI to create container with label
    let output = std::process::Command::new("docker")
        .args([
            "create",
            "--label",
            "devcontainer.is_test_run=true",
            "--name",
            &unique_name,
            base_image,
            "sleep",
            "infinity",
        ])
        .output()
        .map_err(|e| {
            crate::features_test::errors::Error::RuntimeUnavailable(format!(
                "Failed to create container: {}",
                e
            ))
        })?;

    if !output.status.success() {
        return Err(crate::features_test::errors::Error::RuntimeUnavailable(
            format!(
                "Failed to create container: {}",
                String::from_utf8_lossy(&output.stderr)
            ),
        ));
    }

    let container_id = String::from_utf8_lossy(&output.stdout).trim().to_string();
    debug!("Created container: {}", container_id);

    // Start the container
    let start_output = std::process::Command::new("docker")
        .args(["start", &container_id])
        .output()
        .map_err(|e| {
            crate::features_test::errors::Error::RuntimeUnavailable(format!(
                "Failed to start container: {}",
                e
            ))
        })?;

    if !start_output.status.success() {
        return Err(crate::features_test::errors::Error::RuntimeUnavailable(
            format!(
                "Failed to start container: {}",
                String::from_utf8_lossy(&start_output.stderr)
            ),
        ));
    }

    Ok(container_id)
}

/// Generates a timestamp-based identifier for naming temporary resources.
fn unique_identifier(prefix: &str) -> String {
    let pid = std::process::id();
    let nanos = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .map(|d| d.as_nanos())
        .unwrap_or(0);
    format!("{}-{}-{}", prefix, pid, nanos)
}

/// Executes a script inside a container.
///
/// Copies the script from the host to the container, makes it executable, and runs it
/// using the Docker exec API. Cleans up temporary files on both host and container.
///
/// # Arguments
///
/// * `docker` - Docker client
/// * `container_id` - Container ID to execute in
/// * `script_path` - Path to the script file on the host
/// * `remote_user` - Optional user to run the script as
///
/// # Returns
///
/// Returns `true` if the script executed successfully (exit code 0), `false` otherwise.
///
/// # Errors
///
/// Returns an error if:
/// - The script cannot be read from the host
/// - The script cannot be copied to the container
/// - The script cannot be made executable
/// - The Docker exec operation fails
async fn execute_script_in_container(
    docker: &CliDocker,
    container_id: &str,
    script_path: &Path,
    remote_user: Option<&str>,
) -> Result<bool, crate::features_test::errors::Error> {
    debug!(
        "Executing script {:?} in container {}",
        script_path, container_id
    );

    // Read the script content
    let script_content = fs::read_to_string(script_path).map_err(|e| {
        crate::features_test::errors::Error::Io(std::io::Error::other(format!(
            "Failed to read script {:?}: {}",
            script_path, e
        )))
    })?;

    // Copy script to container using docker cp
    let random_id = fastrand::u64(..);
    let temp_script_name = format!("/tmp/test-script-{}.sh", random_id);

    // Write script to temp file on host
    let temp_host_path = std::env::temp_dir().join(format!("deacon-test-{}.sh", random_id));
    fs::write(&temp_host_path, &script_content).map_err(crate::features_test::errors::Error::Io)?;

    // Copy to container
    let host_path = temp_host_path.as_os_str().to_string_lossy();
    let cp_output = std::process::Command::new("docker")
        .args([
            "cp",
            host_path.as_ref(),
            &format!("{}:{}", container_id, temp_script_name),
        ])
        .output()
        .map_err(|e| {
            crate::features_test::errors::Error::RuntimeUnavailable(format!(
                "Failed to copy script to container: {}",
                e
            ))
        })?;

    // Clean up temp host file
    let _ = fs::remove_file(&temp_host_path);

    if !cp_output.status.success() {
        return Err(crate::features_test::errors::Error::RuntimeUnavailable(
            format!(
                "Failed to copy script to container: {}",
                String::from_utf8_lossy(&cp_output.stderr)
            ),
        ));
    }

    // Make script executable
    let chmod_output = std::process::Command::new("docker")
        .args(["exec", container_id, "chmod", "+x", &temp_script_name])
        .output()
        .map_err(|e| {
            crate::features_test::errors::Error::RuntimeUnavailable(format!(
                "Failed to make script executable: {}",
                e
            ))
        })?;

    if !chmod_output.status.success() {
        return Err(crate::features_test::errors::Error::RuntimeUnavailable(
            format!(
                "Failed to make script executable: {}",
                String::from_utf8_lossy(&chmod_output.stderr)
            ),
        ));
    }

    // Execute the script using Docker exec trait
    let config = ExecConfig {
        user: remote_user.map(|u| u.to_string()),
        working_dir: Some("/tmp".to_string()),
        env: HashMap::new(),
        tty: false,
        interactive: false,
        detach: false,
        silent: false,
        terminal_size: None,
    };

    let exec_result = docker
        .exec(
            container_id,
            &["/bin/sh".to_string(), temp_script_name.clone()],
            config,
        )
        .await
        .map_err(|e| crate::features_test::errors::Error::RuntimeUnavailable(e.to_string()))?;

    debug!(
        "Script execution completed with exit code: {}",
        exec_result.exit_code
    );

    if !exec_result.success {
        debug!("Script stdout: {}", exec_result.stdout);
        debug!("Script stderr: {}", exec_result.stderr);
    }

    Ok(exec_result.success)
}

/// Cleans up a test container.
///
/// Forcefully removes the specified container using `docker rm -f`.
///
/// # Arguments
///
/// * `_docker` - Docker client (not currently used, kept for future enhancements)
/// * `container_id` - Container ID to remove
///
/// # Errors
///
/// Returns an error if the container cannot be removed.
#[instrument(
    name = "cleanup",
    skip(_docker),
    fields(container_id = %container_id)
)]
async fn cleanup_container(
    _docker: &CliDocker,
    container_id: &str,
) -> Result<(), crate::features_test::errors::Error> {
    debug!("Cleaning up container: {}", container_id);

    let output = std::process::Command::new("docker")
        .args(["rm", "-f", container_id])
        .output()
        .map_err(|e| {
            crate::features_test::errors::Error::RuntimeUnavailable(format!(
                "Failed to remove container: {}",
                e
            ))
        })?;

    if !output.status.success() {
        return Err(crate::features_test::errors::Error::RuntimeUnavailable(
            format!(
                "Failed to remove container: {}",
                String::from_utf8_lossy(&output.stderr)
            ),
        ));
    }

    Ok(())
}

/// Cleans up all test containers with the `devcontainer.is_test_run` label.
///
/// This function finds and removes all containers labeled with
/// `devcontainer.is_test_run=true`, which are created during test execution.
/// It's typically called at the end of a test run or when cleaning up orphaned
/// test containers.
///
/// # Errors
///
/// Returns an error if:
/// - Docker is unavailable
/// - Containers cannot be listed
/// - Any container cannot be removed
///
/// # Example
///
/// ```no_run
/// use deacon_core::features_test::runner::cleanup_all_test_containers;
///
/// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
/// // Clean up all test containers
/// cleanup_all_test_containers().await?;
/// println!("All test containers removed");
/// # Ok(())
/// # }
/// ```
pub async fn cleanup_all_test_containers() -> Result<(), crate::features_test::errors::Error> {
    debug!("Cleaning up all test containers");

    let docker = CliDocker::new();

    // List all containers with the test label
    let containers = docker
        .list_containers(Some("devcontainer.is_test_run=true"))
        .await
        .map_err(|e| crate::features_test::errors::Error::RuntimeUnavailable(e.to_string()))?;

    for container in containers {
        debug!("Removing test container: {}", container.id);
        cleanup_container(&docker, &container.id).await?;
    }

    Ok(())
}
