//! Discovery functions for test collections, features, and scenarios.
//!
//! This module provides functions to scan the filesystem and discover:
//! - Test collections (validated directory structures with src/ and test/)
//! - Features (subdirectories in src/ with corresponding test directories)
//! - Scenarios (test definitions in scenarios.json or scenarios.jsonc files)
//!
//! The discovery process validates the structure and returns rich metadata about
//! discovered items that can be used by the test runner.

use std::path::Path;

use serde::Deserialize;

use crate::features_test::model::{Feature, Scenario, TestCollection};

/// Discovers a test collection at the given root path.
///
/// Validates that the root path exists and contains the required `src/` and `test/`
/// subdirectories. Returns a [`TestCollection`] with resolved absolute paths and a
/// stable identifier derived from the canonical path.
///
/// # Arguments
///
/// * `root_path` - Path to the test collection root directory
///
/// # Returns
///
/// Returns a [`TestCollection`] with validated paths.
///
/// # Errors
///
/// Returns an error if:
/// - The root path does not exist
/// - The `src/` directory is missing or not a directory
/// - The `test/` directory is missing or not a directory
///
/// # Example
///
/// ```no_run
/// use deacon_core::features_test::discovery::discover_test_collection;
/// use std::path::Path;
///
/// let collection = discover_test_collection(Path::new("/path/to/features"))?;
/// println!("Collection ID: {}", collection.id());
/// println!("Source path: {:?}", collection.src_path());
/// # Ok::<(), Box<dyn std::error::Error>>(())
/// ```
pub fn discover_test_collection(
    root_path: &Path,
) -> Result<TestCollection, crate::features_test::errors::Error> {
    // Validate that root_path exists
    if !root_path.exists() {
        return Err(crate::features_test::errors::Error::CollectionNotFound(
            root_path.display().to_string(),
        ));
    }

    // Construct paths for src/ and test/
    let src_path = root_path.join("src");
    let test_path = root_path.join("test");

    // Validate that both src/ and test/ exist
    let mut missing = Vec::new();
    if !src_path.exists() || !src_path.is_dir() {
        missing.push("src/");
    }
    if !test_path.exists() || !test_path.is_dir() {
        missing.push("test/");
    }

    if !missing.is_empty() {
        return Err(crate::features_test::errors::Error::MissingDirectory(
            missing.join(", "),
        ));
    }

    // Generate an ID from the canonical path
    // canonicalize() resolves symlinks and produces an absolute path,
    // which ensures consistent normalization across platforms
    let canonical_root = root_path.canonicalize().map_err(|e| {
        crate::features_test::errors::Error::Other(format!(
            "Failed to canonicalize root path {}: {}",
            root_path.display(),
            e
        ))
    })?;

    // Canonicalize src and test paths individually for stable path IDs
    let canonical_src = src_path.canonicalize().map_err(|e| {
        crate::features_test::errors::Error::Other(format!(
            "Failed to canonicalize src path {}: {}",
            src_path.display(),
            e
        ))
    })?;

    let canonical_test = test_path.canonicalize().map_err(|e| {
        crate::features_test::errors::Error::Other(format!(
            "Failed to canonicalize test path {}: {}",
            test_path.display(),
            e
        ))
    })?;

    // Use display() which produces a platform-normalized path string
    let id = canonical_root.display().to_string();

    Ok(TestCollection::new(
        id,
        canonical_root,
        canonical_src,
        canonical_test,
    ))
}

/// Discovers all features in a test collection.
///
/// Scans the `src/` directory of the collection and returns a feature for each subdirectory
/// found. For each feature, checks if an autogenerated `test.sh` exists in the corresponding
/// test directory. Features are sorted alphabetically by ID for deterministic ordering.
///
/// # Arguments
///
/// * `collection` - The test collection to scan for features
///
/// # Returns
///
/// Returns a vector of discovered [`Feature`] objects sorted by ID. The `scenarios` field
/// of each feature will be empty and should be populated by calling [`discover_scenarios`].
///
/// # Errors
///
/// Returns an error if:
/// - The `src/` directory cannot be read
/// - Directory entries cannot be read
///
/// # Example
///
/// ```no_run
/// use deacon_core::features_test::discovery::{discover_test_collection, discover_features};
/// use std::path::Path;
///
/// let collection = discover_test_collection(Path::new("/path/to/features"))?;
/// let features = discover_features(&collection)?;
/// for feature in &features {
///     println!("Found feature: {} (autogenerated: {})", feature.id(), feature.has_autogenerated());
/// }
/// # Ok::<(), Box<dyn std::error::Error>>(())
/// ```
pub fn discover_features(
    collection: &TestCollection,
) -> Result<Vec<Feature>, crate::features_test::errors::Error> {
    let mut features = Vec::new();

    // Read the src/ directory
    let src_entries = std::fs::read_dir(collection.src_path()).map_err(|e| {
        crate::features_test::errors::Error::Other(format!("Failed to read src directory: {}", e))
    })?;

    for entry in src_entries {
        let entry = entry.map_err(|e| {
            crate::features_test::errors::Error::Other(format!("Failed to read entry: {}", e))
        })?;

        let path = entry.path();

        // Only consider directories
        if !path.is_dir() {
            continue;
        }

        // Extract feature ID from directory name
        // file_name() returns only the final component (no path separators),
        // which makes discovery cross-platform and supports spaces in feature IDs
        let feature_id = match path.file_name().and_then(|n| n.to_str()) {
            Some(name) => name.to_string(),
            None => continue, // Skip entries with invalid UTF-8 names
        };

        // Construct paths
        let src_dir = collection.src_path().join(&feature_id);
        let test_dir = collection.test_path().join(&feature_id);

        // Check if test.sh exists
        let test_sh_path = test_dir.join("test.sh");
        let has_autogenerated = test_sh_path.exists() && test_sh_path.is_file();

        features.push(Feature::new(
            feature_id,
            src_dir,
            test_dir,
            has_autogenerated,
            Vec::new(), // Will be populated by discover_scenarios
        ));
    }

    // Sort features by ID for deterministic ordering
    features.sort_by(|a, b| a.id().cmp(b.id()));

    Ok(features)
}

/// Helper struct for deserializing scenario definitions from JSON/JSONC files.
#[derive(Deserialize)]
struct ScenarioDefinition {
    name: String,
    #[serde(default)]
    script: Option<String>,
    #[serde(default)]
    config: Option<String>,
}

/// Discovers scenarios for a feature
///
/// Looks for `scenarios.json` or `scenarios.jsonc` in the feature's test directory and parses
/// the scenario definitions. Each scenario must have at least a `name` field.
///
/// **Scenario File Location**: Scenarios MUST be located at `test/<feature>/scenarios.json`
/// or `test/<feature>/scenarios.jsonc`. No other locations are checked.
///
/// # Arguments
///
/// * `feature` - The feature to discover scenarios for
///
/// # Returns
///
/// Returns a vector of discovered scenarios. If no scenarios file exists, returns an empty vector.
///
/// # Errors
///
/// Returns an error if:
/// - The scenarios file exists but cannot be read
/// - The scenarios file is not valid JSON/JSONC (parse errors include file path and line/column)
/// - The scenarios file does not contain a JSON array
/// - Any scenario object is missing the required `name` field
///
/// # Example Scenario File Format
///
/// ```json
/// [
///   {
///     "name": "basic",
///     "script": "basic.sh"
///   },
///   {
///     "name": "with-options",
///     "config": "with-options.jsonc"
///   }
/// ]
/// ```
///
/// If the `script` field is omitted, the script path defaults to `<name>.sh`.
pub fn discover_scenarios(
    feature: &Feature,
) -> Result<Vec<Scenario>, crate::features_test::errors::Error> {
    let mut scenarios = Vec::new();

    // Look for scenarios.json or scenarios.jsonc in the test directory
    let json_path = feature.test_dir().join("scenarios.json");
    let jsonc_path = feature.test_dir().join("scenarios.jsonc");

    let scenarios_path = if json_path.exists() {
        Some(json_path)
    } else if jsonc_path.exists() {
        Some(jsonc_path)
    } else {
        None
    };

    // If no scenarios file exists, return empty vector (not an error)
    let scenarios_path = match scenarios_path {
        Some(p) => p,
        None => return Ok(Vec::new()),
    };

    // Read the scenarios file
    let content = std::fs::read_to_string(&scenarios_path).map_err(|e| {
        crate::features_test::errors::Error::ScenarioParse(format!(
            "Failed to read {}: {}",
            scenarios_path.display(),
            e
        ))
    })?;

    // Parse as JSON5 (supports JSONC with comments and trailing commas)
    // Deserialize directly into Vec<ScenarioDefinition>
    // Note: json5::Error includes line and column information in its Display output
    let scenario_defs: Vec<ScenarioDefinition> = json5::from_str(&content).map_err(|e| {
        crate::features_test::errors::Error::ScenarioParse(format!(
            "Failed to parse {} ({})",
            scenarios_path.display(),
            e
        ))
    })?;

    // Process each scenario definition
    for def in scenario_defs {
        // Determine the script path
        // Use explicit 'script' field, otherwise default to <name>.sh
        let script_name = def.script.unwrap_or_else(|| format!("{}.sh", def.name));

        let script_path = feature.test_dir().join(&script_name);

        // Build optional config path if specified
        let config_path = def.config.map(|c| feature.test_dir().join(c));

        scenarios.push(Scenario::new(
            feature.id().to_string(),
            def.name,
            script_path,
            config_path,
        ));
    }

    Ok(scenarios)
}

/// Filters features based on selected feature IDs
///
/// # Arguments
///
/// * `features` - Vector of features to filter
/// * `selected_features` - Optional list of feature IDs to include (case-sensitive)
///
/// # Returns
///
/// Returns a filtered vector of features. If `selected_features` is None, returns all features.
/// If Some, returns only features whose IDs are in the selected list.
///
/// # Example
///
/// ```
/// use deacon_core::features_test::model::Feature;
/// use deacon_core::features_test::discovery::filter_features;
/// use std::path::PathBuf;
///
/// let features = vec![
///     Feature::new(
///         "color".to_string(),
///         PathBuf::from("/test/src/color"),
///         PathBuf::from("/test/test/color"),
///         true,
///         Vec::new(),
///     ),
///     Feature::new(
///         "node".to_string(),
///         PathBuf::from("/test/src/node"),
///         PathBuf::from("/test/test/node"),
///         true,
///         Vec::new(),
///     ),
/// ];
///
/// // Filter to only "color"
/// let filtered = filter_features(features.clone(), Some(vec!["color".to_string()]));
/// assert_eq!(filtered.len(), 1);
/// assert_eq!(filtered[0].id(), "color");
///
/// // No filter returns all
/// let all = filter_features(features.clone(), None);
/// assert_eq!(all.len(), 2);
/// ```
pub fn filter_features(
    features: Vec<Feature>,
    selected_features: Option<Vec<String>>,
) -> Vec<Feature> {
    match selected_features {
        Some(selected) => features
            .into_iter()
            .filter(|f| selected.contains(&f.id().to_string()))
            .collect(),
        None => features,
    }
}

/// Filters scenarios based on a case-sensitive substring match on scenario names
///
/// # Arguments
///
/// * `scenarios` - Vector of scenarios to filter
/// * `filter` - Optional case-sensitive substring to match against scenario names
///
/// # Returns
///
/// Returns a filtered vector of scenarios. If `filter` is None, returns all scenarios.
/// If Some, returns only scenarios whose names contain the filter string (case-sensitive).
///
/// # Example
///
/// ```
/// use deacon_core::features_test::model::Scenario;
/// use deacon_core::features_test::discovery::filter_scenarios;
/// use std::path::PathBuf;
///
/// let scenarios = vec![
///     Scenario::new(
///         "color".to_string(),
///         "basic-test".to_string(),
///         PathBuf::from("/test/test/color/basic.sh"),
///         None,
///     ),
///     Scenario::new(
///         "color".to_string(),
///         "advanced-config".to_string(),
///         PathBuf::from("/test/test/color/advanced.sh"),
///         None,
///     ),
/// ];
///
/// // Filter by substring "basic"
/// let filtered = filter_scenarios(scenarios.clone(), Some("basic".to_string()));
/// assert_eq!(filtered.len(), 1);
/// assert_eq!(filtered[0].name(), "basic-test");
///
/// // Case-sensitive: "Basic" should not match "basic-test"
/// let no_match = filter_scenarios(scenarios.clone(), Some("Basic".to_string()));
/// assert_eq!(no_match.len(), 0);
///
/// // No filter returns all
/// let all = filter_scenarios(scenarios.clone(), None);
/// assert_eq!(all.len(), 2);
/// ```
pub fn filter_scenarios(scenarios: Vec<Scenario>, filter: Option<String>) -> Vec<Scenario> {
    match filter {
        Some(filter_str) => scenarios
            .into_iter()
            .filter(|s| s.name().contains(&filter_str))
            .collect(),
        None => scenarios,
    }
}
