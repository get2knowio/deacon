//! Tests for cross-platform path normalization and discovery consistency.
//!
//! This module verifies that the features test discovery system:
//! - Normalizes path separators across platforms (Windows `\` vs Unix `/`)
//! - Maintains case-sensitive discovery behavior
//! - Supports spaces and special characters in paths and feature IDs

use deacon_core::features_test::discovery;
use std::fs;
use std::path::Path;
use tempfile::tempdir;

/// Helper to create a minimal valid test collection with the given feature IDs
fn create_test_collection_with_features(feature_ids: &[&str]) -> tempfile::TempDir {
    let tmp = tempdir().expect("create temp dir");
    let root = tmp.path();

    // Create src/ and test/ directories
    fs::create_dir(root.join("src")).expect("create src dir");
    fs::create_dir(root.join("test")).expect("create test dir");

    // Create feature directories
    for feature_id in feature_ids {
        let src_feature = root.join("src").join(feature_id);
        let test_feature = root.join("test").join(feature_id);

        fs::create_dir(&src_feature).expect("create src feature dir");
        fs::create_dir(&test_feature).expect("create test feature dir");

        // Create test.sh for autogenerated tests
        let test_sh = test_feature.join("test.sh");
        fs::write(&test_sh, "#!/bin/bash\nexit 0\n").expect("write test.sh");
    }

    tmp
}

#[test]
fn discover_features_with_spaces_in_feature_id() {
    // Create a collection with a feature ID that contains spaces
    let feature_id = "my feature";
    let tmp = create_test_collection_with_features(&[feature_id]);

    let collection = discovery::discover_test_collection(tmp.path()).expect("discover collection");
    let features = discovery::discover_features(&collection).expect("discover features");

    assert_eq!(features.len(), 1);
    assert_eq!(features[0].id(), feature_id);
    assert!(features[0].has_autogenerated());
}

#[test]
fn discover_features_with_spaces_in_collection_path() {
    // Create a nested directory structure with spaces in the path
    let tmp = tempdir().expect("create temp dir");
    let nested = tmp.path().join("my collections").join("feature tests");
    fs::create_dir_all(&nested).expect("create nested dirs");

    // Create src/ and test/ directories in the nested path
    fs::create_dir(nested.join("src")).expect("create src dir");
    fs::create_dir(nested.join("test")).expect("create test dir");

    // Create a simple feature
    let feature_id = "color";
    fs::create_dir(nested.join("src").join(feature_id)).expect("create src feature");
    fs::create_dir(nested.join("test").join(feature_id)).expect("create test feature");
    fs::write(
        nested.join("test").join(feature_id).join("test.sh"),
        "#!/bin/bash\nexit 0\n",
    )
    .expect("write test.sh");

    // Discovery should work with spaces in the collection path
    let collection = discovery::discover_test_collection(&nested).expect("discover collection");
    let features = discovery::discover_features(&collection).expect("discover features");

    assert_eq!(features.len(), 1);
    assert_eq!(features[0].id(), feature_id);
}

#[test]
fn discover_test_collection_normalizes_paths() {
    // Create a test collection
    let tmp = create_test_collection_with_features(&["color"]);
    let path = tmp.path();

    let collection = discovery::discover_test_collection(path).expect("discover collection");

    // All paths should be absolute and normalized
    assert!(collection.root_path().is_absolute());
    assert!(collection.src_path().is_absolute());
    assert!(collection.test_path().is_absolute());

    // Paths should end with expected components
    assert!(collection.src_path().ends_with("src"));
    assert!(collection.test_path().ends_with("test"));
}

#[test]
fn discover_test_collection_with_relative_path() {
    // Create a test collection
    let tmp = create_test_collection_with_features(&["color"]);

    // Get a relative path (if possible) by joining with "."
    let relative_path = Path::new(".").join(tmp.path());

    // Discovery should work and produce absolute paths
    let collection =
        discovery::discover_test_collection(&relative_path).expect("discover collection");

    // Even with relative input, output should be absolute
    assert!(collection.root_path().is_absolute());
    assert!(collection.src_path().is_absolute());
    assert!(collection.test_path().is_absolute());
}

#[test]
#[cfg_attr(any(target_os = "macos", target_os = "windows"), ignore)]
fn discover_features_case_sensitive() {
    // Create features with names that differ only in case
    // Note: This test requires a case-sensitive filesystem (Linux)
    // Skipped on macOS/Windows where filesystems are case-insensitive by default
    let tmp = create_test_collection_with_features(&["Color", "color"]);

    let collection = discovery::discover_test_collection(tmp.path()).expect("discover collection");
    let features = discovery::discover_features(&collection).expect("discover features");

    // On case-sensitive filesystems (Linux), both should be discovered
    // On case-insensitive filesystems (macOS default, Windows), only one will exist
    // We assert that discovery respects whatever the filesystem provides
    assert!(
        !features.is_empty(),
        "At least one feature should be discovered"
    );
    assert!(
        features.len() <= 2,
        "At most two features should be discovered"
    );

    // All discovered features should have distinct IDs
    let ids: Vec<&str> = features.iter().map(|f| f.id()).collect();
    let unique_ids: std::collections::HashSet<_> = ids.iter().collect();
    assert_eq!(
        ids.len(),
        unique_ids.len(),
        "All discovered feature IDs should be distinct"
    );
}

#[test]
fn discover_features_sorted_case_sensitive() {
    // Create features with mixed case to verify sort is case-sensitive
    let tmp = create_test_collection_with_features(&["Zulu", "alpha", "Bravo", "charlie"]);

    let collection = discovery::discover_test_collection(tmp.path()).expect("discover collection");
    let features = discovery::discover_features(&collection).expect("discover features");

    assert_eq!(features.len(), 4);

    // Features should be sorted case-sensitively (uppercase before lowercase in ASCII)
    let ids: Vec<&str> = features.iter().map(|f| f.id()).collect();
    assert_eq!(ids, vec!["Bravo", "Zulu", "alpha", "charlie"]);
}

#[test]
fn filter_features_case_sensitive() {
    // Create features with distinct names to test case-sensitive filtering
    let tmp = create_test_collection_with_features(&["myFeature", "node", "python"]);

    let collection = discovery::discover_test_collection(tmp.path()).expect("discover collection");
    let features = discovery::discover_features(&collection).expect("discover features");

    assert_eq!(features.len(), 3);

    // Filter with exact case match should work
    let filtered =
        discovery::filter_features(features.clone(), Some(vec!["myFeature".to_string()]));
    assert_eq!(filtered.len(), 1);
    assert_eq!(filtered[0].id(), "myFeature");

    // Different case should not match (case-sensitive filtering)
    let filtered_wrong_case =
        discovery::filter_features(features, Some(vec!["myfeature".to_string()]));
    assert_eq!(
        filtered_wrong_case.len(),
        0,
        "Case-sensitive: 'myfeature' should not match 'myFeature'"
    );
}

#[test]
fn discover_features_with_special_characters_in_id() {
    // Create features with hyphens and underscores (common in feature IDs)
    let feature_ids = ["my-feature", "my_feature", "my.feature"];
    let tmp = create_test_collection_with_features(&feature_ids);

    let collection = discovery::discover_test_collection(tmp.path()).expect("discover collection");
    let features = discovery::discover_features(&collection).expect("discover features");

    assert_eq!(features.len(), 3);

    // Verify all features are discovered with correct IDs
    let ids: Vec<&str> = features.iter().map(|f| f.id()).collect();
    assert_eq!(ids, vec!["my-feature", "my.feature", "my_feature"]);
}

#[test]
fn discover_features_constructs_correct_paths() {
    // Create a feature with spaces
    let feature_id = "my feature";
    let tmp = create_test_collection_with_features(&[feature_id]);

    let collection = discovery::discover_test_collection(tmp.path()).expect("discover collection");
    let features = discovery::discover_features(&collection).expect("discover features");

    assert_eq!(features.len(), 1);
    let feature = &features[0];

    // Verify paths are constructed correctly
    assert!(feature.src_dir().ends_with("my feature"));
    assert!(feature.test_dir().ends_with("my feature"));

    // Verify paths exist and are directories
    assert!(feature.src_dir().is_dir());
    assert!(feature.test_dir().is_dir());

    // Verify test.sh path is correct
    let test_sh = feature.test_dir().join("test.sh");
    assert!(test_sh.exists());
}

#[test]
fn discover_features_sorted_deterministically() {
    // Create features in random order
    let feature_ids = ["zulu", "alpha", "bravo", "charlie"];
    let tmp = create_test_collection_with_features(&feature_ids);

    let collection = discovery::discover_test_collection(tmp.path()).expect("discover collection");
    let features = discovery::discover_features(&collection).expect("discover features");

    // Features should be sorted alphabetically
    let ids: Vec<&str> = features.iter().map(|f| f.id()).collect();
    assert_eq!(ids, vec!["alpha", "bravo", "charlie", "zulu"]);
}

#[test]
fn discover_scenarios_with_spaces_in_path() {
    // Create a feature with spaces in the ID
    let feature_id = "my feature";
    let tmp = create_test_collection_with_features(&[feature_id]);

    let collection = discovery::discover_test_collection(tmp.path()).expect("discover collection");
    let features = discovery::discover_features(&collection).expect("discover features");

    // Create a scenarios.json file
    let scenarios_json = r#"[
        {
            "name": "basic",
            "script": "basic.sh"
        }
    ]"#;
    fs::write(
        tmp.path()
            .join("test")
            .join(feature_id)
            .join("scenarios.json"),
        scenarios_json,
    )
    .expect("write scenarios.json");

    // Create the scenario script
    fs::write(
        tmp.path().join("test").join(feature_id).join("basic.sh"),
        "#!/bin/bash\nexit 0\n",
    )
    .expect("write basic.sh");

    // Discover scenarios
    let scenarios = discovery::discover_scenarios(&features[0]).expect("discover scenarios");

    assert_eq!(scenarios.len(), 1);
    assert_eq!(scenarios[0].name(), "basic");
    assert_eq!(scenarios[0].feature_id(), feature_id);
    assert!(scenarios[0].script_path().exists());
}

#[test]
fn discover_scenarios_with_spaces_in_scenario_name() {
    // Create a simple feature
    let feature_id = "color";
    let tmp = create_test_collection_with_features(&[feature_id]);

    let collection = discovery::discover_test_collection(tmp.path()).expect("discover collection");
    let features = discovery::discover_features(&collection).expect("discover features");

    // Create scenarios with spaces in names
    let scenarios_json = r#"[
        {
            "name": "basic test",
            "script": "basic-test.sh"
        },
        {
            "name": "advanced config test"
        }
    ]"#;
    fs::write(
        tmp.path()
            .join("test")
            .join(feature_id)
            .join("scenarios.json"),
        scenarios_json,
    )
    .expect("write scenarios.json");

    // Discover scenarios
    let scenarios = discovery::discover_scenarios(&features[0]).expect("discover scenarios");

    assert_eq!(scenarios.len(), 2);
    assert_eq!(scenarios[0].name(), "basic test");
    assert_eq!(scenarios[1].name(), "advanced config test");

    // Verify script paths are constructed correctly
    assert!(scenarios[0].script_path().ends_with("basic-test.sh"));
    assert!(scenarios[1]
        .script_path()
        .ends_with("advanced config test.sh"));
}

#[test]
fn filter_scenarios_case_sensitive() {
    use deacon_core::features_test::model::Scenario;
    use std::path::PathBuf;

    let scenarios = vec![
        Scenario::new(
            "color".to_string(),
            "Basic".to_string(),
            PathBuf::from("/test/basic.sh"),
            None,
        ),
        Scenario::new(
            "color".to_string(),
            "basic".to_string(),
            PathBuf::from("/test/basic2.sh"),
            None,
        ),
        Scenario::new(
            "color".to_string(),
            "BASIC".to_string(),
            PathBuf::from("/test/basic3.sh"),
            None,
        ),
    ];

    // Filter is case-sensitive: should only match exact substring
    let filtered = discovery::filter_scenarios(scenarios.clone(), Some("basic".to_string()));
    assert_eq!(filtered.len(), 1);
    assert_eq!(filtered[0].name(), "basic");

    // Different case should not match
    let filtered_cap = discovery::filter_scenarios(scenarios, Some("BASIC".to_string()));
    assert_eq!(filtered_cap.len(), 1);
    assert_eq!(filtered_cap[0].name(), "BASIC");
}
